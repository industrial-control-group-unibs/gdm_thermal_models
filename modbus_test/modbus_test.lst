***********************************************************************
*
*	CODE GENERATION LISTING FOR: modbus_test
*	COMPILER VERSION: 5.98.9.8
*
***********************************************************************

**************************************************
	List function: _InOutVersion
**************************************************

FUNCTION _InOutVersion : UDINT

{ DE:"LIBRERIA: ADV200 InOut

Rev.01.20.00	14/12/2006 By FRD
Rev.01.30.00	28/05/2008 By RNC


This library contains functions and function blocks for the input/output management:
Motor current conversion to/from FW;
Motor speed conversion   to/from FW.

Note:
No global variables are used, so that the library can be used regardless the FW version" }

	VAR_INPUT
	in : BOOL; 
	END_VAR

	*** Function data allocation

	Par in: REGISTER d4

#0		{SRC:_InOutVersion}
#1		
#2		
#3			LD		in
(*) UNDEF
A0010080  F1F0400B		mov d15, d4

#4			JMPC	l0_Version
(-) BOOL
A0010084  800E0FDF		jne d15, #0, #0x000E ; JUMP 0xA00100A0

#5		
#6			LD		0
(*) UNDEF
A0010088  F000003B		mov d15, #0

#7			ST		_InOutVersion
(*) USINT
A001008C  21F0F00B		mov d2, d15

#8		
#9			RET
(-) USINT
A0010090  FA001091		movh.a a15, #0xA001 ; 0xA00100A8
A0010094  2028FFD9		lea a15,[a15]0x00A8
A0010098  0000000D		nop
A001009C  00300F2D		ji a15

#10		
#11		l0_Version:
#12		
#13			(*	Indice di revisione.						*)
#14			(*	L'indice si legge nella seguente maniera:	*)
#15			(*	XXYYZZ => XX.YY.ZZ 							*)
#16			(*	XX = Revisione								*)
#17			(*	YY = Sotto revisione						*)
#18			(*	ZZ = Correzione								*)
#19		
#20			LD		013000
(*) UNDEF
A00100A0  F32C803B		mov d15, #13000

#21			ST		_InOutVersion
(*) UINT
A00100A4  21F0F00B		mov d2, d15

A00100A8  0180000D		ret

END_FUNCTION
**************************************************
	List function: TrqToCount
**************************************************

FUNCTION TrqToCount : DINT

{ DE:"F Name: TrqToCount ADV200
Copyright © 2008, SIEI SpA. All Rights Reserved.

 Version     : 01.00
 Data        :  2008
 Author      : Gefran

Description:
Convert torque in percentage to torque in internal unit (Counts)
16#20000000 counts correspond to 100% motor torque
100% of motor torque is the torque obtained with the
maximum Torque current (nominal current cleaned of 
magnetizing current)" }

	VAR_INPUT
	InTrqPerc : REAL; 
	END_VAR

	*** Function data allocation

	Par InTrqPerc: REGISTER d4

#0		{SRC:TrqToCount}
#1		
#2			(* TrqToCount := TO_DINT(InTrqPerc * 5368709.12); *)
#3			LD		InTrqPerc	{L:6}
(*) UNDEF
A00100AC  F1F0400B		mov d15, d4

#4			MUL		5368709.12	{L:6}
(*) REAL
A00100B0  8D70A0BB		mov.u d8, #0xD70A ; COSTREAL 5368709.120000
A00100B4  84AA389B		addih d8, d8, #0x4AA3
A00100B8  F0418F4B		mul.f d15, d15, d8

#5			TO_DINT	{L:6}
(*) REAL
A00100BC  F1010F4B		ftoi d15, d15

#6			ST		TrqToCount	{L:6}
(*) DINT
A00100C0  21F0F00B		mov d2, d15

A00100C4  0180000D		ret

END_FUNCTION
**************************************************
	List function: CountToTrq
**************************************************

FUNCTION CountToTrq : REAL

{ DE:"F Name: CountToRpm ADV200
Copyright © 2008, SIEI SpA. All Rights Reserved.

 Version     : 01.00
 Data        :  2008
 Author      : Gefran

Description:
Convert torque in internal unit (Count) to torque in percentage  
16#20000000 counts correspond to 100% motor torque
100% of motor torque is the torque obtained with the
maximum Torque current (nominal current cleaned of 
magnetizing current)" }

	VAR_INPUT
	InTrqCnt : DINT; 
	END_VAR

	*** Function data allocation

	Par InTrqCnt: REGISTER d4

#0		{SRC:CountToTrq}
#1		
#2			(* CountToTrq := TO_REAL(InTrqCnt) / 5368709.12; *)
#3			LD		InTrqCnt	{L:6}
(*) UNDEF
A00100C8  F1F0400B		mov d15, d4

#4			TO_REAL	{L:6}
(*) DINT
A00100CC  F1410F4B		itof d15, d15

#5			DIV		5368709.12	{L:6}
(*) REAL
A00100D0  8D70A0BB		mov.u d8, #0xD70A ; COSTREAL 5368709.120000
A00100D4  84AA389B		addih d8, d8, #0x4AA3
A00100D8  F0518F4B		div.f d15, d15, d8

#6			ST		CountToTrq	{L:6}
(*) REAL
A00100DC  21F0F00B		mov d2, d15

A00100E0  0180000D		ret

END_FUNCTION
**************************************************
	List function: AmpToCount
**************************************************

FUNCTION AmpToCount : DINT

{ DE:"F Name: RpmToCount ADV200
Copyright © 2008, SIEI SpA. All Rights Reserved.

 Version     : 01.00
 Data        :  2008
 Author      : Gefran

Description:
Convert current in Amp to current internal units (Counts)
16#20000000 counts correspond to Drive cont current" }

	VAR_INPUT
	InCurrAmp : REAL; 
	inFSDriveCntCurrent : REAL; { DE:"Drive cont current set in the drive " } 
	END_VAR

	*** Function data allocation

	Par InCurrAmp: REGISTER d4
	Par inFSDriveCntCurrent: REGISTER d5

#0		{SRC:AmpToCount}
#1		
#2			(* AmpToCount := TO_DINT(InCurrAmp * 536870912.0 / inFSDriveCntCurrent); *)
#3			LD		InCurrAmp	{L:6}
(*) UNDEF
A00100E4  F1F0400B		mov d15, d4

#4			MUL		536870912.0	{L:6}
(*) REAL
A00100E8  800000BB		mov.u d8, #0x0000 ; COSTREAL 536870912.000000
A00100EC  84E0089B		addih d8, d8, #0x4E00
A00100F0  F0418F4B		mul.f d15, d15, d8

#5			DIV		inFSDriveCntCurrent	{L:6}
(*) REAL
A00100F4  81F0500B		mov d8, d5
A00100F8  F0518F4B		div.f d15, d15, d8

#6			TO_DINT	{L:6}
(*) REAL
A00100FC  F1010F4B		ftoi d15, d15

#7			ST		AmpToCount	{L:6}
(*) DINT
A0010100  21F0F00B		mov d2, d15

A0010104  0180000D		ret

END_FUNCTION
**************************************************
	List function: CountToAmp
**************************************************

FUNCTION CountToAmp : REAL

{ DE:"FBlock Name: CountToRpm ADV200
Copyright © 2008, SIEI SpA. All Rights Reserved.

 Version     : 01.00
 Data        :  2008
 Author      : Gefran

Description:
Convert current in internal unit (Count) to current in Amp  
16#20000000 counts correspond to Drive cont current 
" }

	VAR_INPUT
	InCurrCnt : DINT; 
	inFSDriveCntCurrent : REAL; { DE:"Drive cont current set in the drive" } 
	END_VAR

	*** Function data allocation

	Par InCurrCnt: REGISTER d4
	Par inFSDriveCntCurrent: REGISTER d5

#0		{SRC:CountToAmp}
#1		
#2			(* CountToAmp := (TO_REAL(InCurrCnt) * inFSDriveCntCurrent) / 536870912.0  ; *)
#3			LD		InCurrCnt	{L:6}
(*) UNDEF
A0010108  F1F0400B		mov d15, d4

#4			TO_REAL	{L:6}
(*) DINT
A001010C  F1410F4B		itof d15, d15

#5			MUL		inFSDriveCntCurrent	{L:6}
(*) REAL
A0010110  F0415F4B		mul.f d15, d15, d5

#6			DIV		536870912.0	{L:6}
(*) REAL
A0010114  800000BB		mov.u d8, #0x0000 ; COSTREAL 536870912.000000
A0010118  84E0089B		addih d8, d8, #0x4E00
A001011C  F0518F4B		div.f d15, d15, d8

#7			ST		CountToAmp	{L:6}
(*) REAL
A0010120  21F0F00B		mov d2, d15

A0010124  0180000D		ret

END_FUNCTION
**************************************************
	List function: RpmToCount
**************************************************

FUNCTION RpmToCount : DINT

{ DE:"F Name: RpmToCount ADV200
Copyright © 2008, SIEI SpA. All Rights Reserved.

 Version     : 01.00
 Data        :  2008
 Author      : Gefran

Description:
Convert speed in RPM to speed internal units (Count)
16#40000000 counts correspond to FullScaleSpeed" }

	VAR_INPUT
	InSpdRpm : REAL; 
	inFSSpeed : DINT; { DE:"Full Scale Speed set in the drive " } 
	END_VAR

	*** Function data allocation

	Par InSpdRpm: REGISTER d4
	Par inFSSpeed: REGISTER d5

#0		{SRC:RpmToCount}
#1		
#2			(* RpmToCount := TO_DINT(InSpdRpm * 1073741824.0 / TO_REAL(inFSSpeed)); *)
#3			LD		InSpdRpm	{L:6}
(*) UNDEF
A0010128  F1F0400B		mov d15, d4

#4			MUL		1073741824.0	{L:6}
(*) REAL
A001012C  800000BB		mov.u d8, #0x0000 ; COSTREAL 1073741824.000000
A0010130  84E8089B		addih d8, d8, #0x4E80
A0010134  F0418F4B		mul.f d15, d15, d8

#5			DIV(		inFSSpeed	{L:6}
(*) REAL
A0010138  F53CAF89		st.w [-sp]4, d15 
A001013C  F1F0500B		mov d15, d5

#6			TO_REAL	{L:6}
(*) DINT
A0010140  F1410F4B		itof d15, d15

#7			)	{L:6}
(*) REAL
A0010144  01F0F00B		mov d0, d15
A0010148  0104AF09		ld.w d15, [sp+]4
A001014C  81F0000B		mov d8, d0
A0010150  F0518F4B		div.f d15, d15, d8

#8			TO_DINT	{L:6}
(*) REAL
A0010154  F1010F4B		ftoi d15, d15

#9			ST		RpmToCount	{L:6}
(*) DINT
A0010158  21F0F00B		mov d2, d15

A001015C  0180000D		ret

END_FUNCTION
**************************************************
	List function: CountToRpm
**************************************************

FUNCTION CountToRpm : REAL

{ DE:"FBlock Name: CountToRpm ADV200
Copyright © 2008, SIEI SpA. All Rights Reserved.

 Version     : 01.00
 Data        :  2008
 Author      : Gefran

Description:
Convert speed in internal units (Count) to speed RPM  
16#40000000 counts correspond to FullScaleSpeed
" }

	VAR_INPUT
	InSpdCnt : DINT; 
	inFSSpeed : DINT; { DE:"Full Scale Speed set in the drive" } 
	END_VAR

	*** Function data allocation

	Par InSpdCnt: REGISTER d4
	Par inFSSpeed: REGISTER d5

#0		{SRC:CountToRpm}
#1		
#2			(* CountToRpm := (TO_REAL(InSpdCnt) * TO_REAL(inFSSpeed)) / 1073741824.0  ; *)
#3			LD		inFSSpeed	{L:6}
(*) UNDEF
A0010160  F1F0500B		mov d15, d5

#4			TO_REAL	{L:6}
(*) DINT
A0010164  F1410F4B		itof d15, d15

#5			MUL(		InSpdCnt	{L:6}
(*) REAL
A0010168  F53CAF89		st.w [-sp]4, d15 
A001016C  F1F0400B		mov d15, d4

#6			TO_REAL	{L:6}
(*) DINT
A0010170  F1410F4B		itof d15, d15

#7			)	{L:6}
(*) REAL
A0010174  01F0F00B		mov d0, d15
A0010178  0104AF09		ld.w d15, [sp+]4
A001017C  F0410F4B		mul.f d15, d15, d0

#8			DIV		1073741824.0	{L:6}
(*) REAL
A0010180  800000BB		mov.u d8, #0x0000 ; COSTREAL 1073741824.000000
A0010184  84E8089B		addih d8, d8, #0x4E80
A0010188  F0518F4B		div.f d15, d15, d8

#9			ST		CountToRpm	{L:6}
(*) REAL
A001018C  21F0F00B		mov d2, d15

A0010190  0180000D		ret

END_FUNCTION
**************************************************
	List function: UnitToAo
**************************************************

FUNCTION UnitToAo : DINT

{ DE:"9/10/2001		by MCC/SSS
05 giu 08       Rnc

UnitToAo: Convert phisycal unit (rpm. Amp, Trq) to Analog Out. FullScale correspond to 10V.
" }

	VAR_INPUT
	inp : REAL; { DE:"Unit Input value " } 
	inSignalBase : REAL; { DE:"FullScaleSpeed for rpm, DriveCntCurr for amp, 100.0 for trq" } 
	END_VAR

	*** Function data allocation

	Par inp: REGISTER d4
	Par inSignalBase: REGISTER d5

#0		{SRC:UnitToAo}
#1		
#2			(* UnitToAo := TO_DINT(inp*1073741824.0/inSignalBase); *)
#3			LD		inp	{L:2}
(*) UNDEF
A0010194  F1F0400B		mov d15, d4

#4			MUL		1073741824.0	{L:2}
(*) REAL
A0010198  800000BB		mov.u d8, #0x0000 ; COSTREAL 1073741824.000000
A001019C  84E8089B		addih d8, d8, #0x4E80
A00101A0  F0418F4B		mul.f d15, d15, d8

#5			DIV		inSignalBase	{L:2}
(*) REAL
A00101A4  81F0500B		mov d8, d5
A00101A8  F0518F4B		div.f d15, d15, d8

#6			TO_DINT	{L:2}
(*) REAL
A00101AC  F1010F4B		ftoi d15, d15

#7			ST		UnitToAo	{L:2}
(*) DINT
A00101B0  21F0F00B		mov d2, d15

A00101B4  0180000D		ret

END_FUNCTION
**************************************************
	List function: AiToUnit
**************************************************

FUNCTION AiToUnit : REAL

{ DE:"9/10/2001		by MCC/SSS
05 giu 08       Rnc

AiToUnit: Convert input voltage in phisycal unit (rpm. Amp, Trq). 10V correspond FullScale.
" }

	VAR_INPUT
	inp : DINT; { DE:"analog input value value " } 
	inSignalBase : REAL; { DE:"FullScaleSpeed for rpm, DriveCntCurr for amp, 100.0 for trq" } 
	END_VAR

	*** Function data allocation

	Par inp: REGISTER d4
	Par inSignalBase: REGISTER d5

#0		{SRC:AiToUnit}
#1		
#2			(* AiToUnit := TO_REAL(inp)*inSignalBase/1073741824.0; *)
#3			LD		inp	{L:2}
(*) UNDEF
A00101B8  F1F0400B		mov d15, d4

#4			TO_REAL	{L:2}
(*) DINT
A00101BC  F1410F4B		itof d15, d15

#5			MUL		inSignalBase	{L:2}
(*) REAL
A00101C0  F0415F4B		mul.f d15, d15, d5

#6			DIV		1073741824.0	{L:2}
(*) REAL
A00101C4  800000BB		mov.u d8, #0x0000 ; COSTREAL 1073741824.000000
A00101C8  84E8089B		addih d8, d8, #0x4E80
A00101CC  F0518F4B		div.f d15, d15, d8

#7			ST		AiToUnit	{L:2}
(*) REAL
A00101D0  21F0F00B		mov d2, d15

A00101D4  0180000D		ret

END_FUNCTION
**************************************************
	List function: ReadCommand
**************************************************

FUNCTION ReadCommand : BOOL

{ DE:"Digital command management

3 sources are available:
digital parameter
digital input
remote command (typically fieldbus)

selection selecs which source to read:
-2= digital parameter, -1= remote command, >=0 = digital input

the function result is reset to FALSE
then the digital command is copied in the output (if selected)
if a digital input is selected, its value will be the function output (if selected
if not, the remote command bit will be the function output (if selected)
" }

	VAR_INPUT
	digpar : BOOL; 
	digitalInputs : UINT; 
	selection : INT; { DE:"-2=digpar, -1=remote, >=0= digital input" } 
	remoteCommand : UINT; 
	nBitRemoteCommand : UINT; 
	END_VAR

	*** Function data allocation

	Par digpar: REGISTER d4
	Par digitalInputs: REGISTER d5
	Par selection: REGISTER d6
	Par remoteCommand: REGISTER d7
	Par nBitRemoteCommand: LOCAL STACK FRAME AT 0(sp)

A00101D8  A1F0400B		mov d10, d4
A00101DC  B1F0500B		mov d11, d5
A00101E0  C1F0600B		mov d12, d6
A00101E4  D1F0700B		mov d13, d7
A00101E8  C000A001		mov.aa a12, sp
A00101EC  800040BB		mov.u d8, #4
A00101F0  E6308001		mov.a a14, d8
A00101F4  A020EA01		sub.a sp, sp, a14

#0		{SRC:ReadCommand}
#1		
#2			(* ReadCommand := FALSE; *)
#3			LD		FALSE	{L:3}
(*) UNDEF
A00101F8  F000003B		mov d15, #0

#4			ST		ReadCommand	{L:3}
(*) BOOL
A00101FC  21F0F00B		mov d2, d15

#5		
#6		
#7			(* IF selection = -1 *)
#8			LD		selection	{L:8}
(*) UNDEF
A0010200  F1F0C00B		mov d15, d12

#9			EQ		-1	{L:8}
(*) INT
A0010204  8FFFF03B		mov d8, #-1
A0010208  F1008F0B		eq d15, d15, d8

#10			JMPCN	$label0	{L:8}
(-) BOOL
A001020C  000E0FDF		jeq d15, #0, #0x000E ; JUMP 0xA0010228

#11		
#12			(* THEN *)
#13		
#14				(* ReadCommand := digpar; *)
#15				LD		digpar	{L:11}
(*) UNDEF
A0010210  F1F0A00B		mov d15, d10

#16				ST		ReadCommand	{L:11}
(*) BOOL
A0010214  21F0F00B		mov d2, d15

#17		
#18				(* RETURN *)
#19				RET
(-) BOOL
A0010218  FA001091		movh.a a15, #0xA001 ; 0xA00102BC
A001021C  A03CFFD9		lea a15,[a15]0x02BC
A0010220  0000000D		nop
A0010224  00300F2D		ji a15

#20		
#21		$label0:
#22			(* END_IF *)
#23		
#24		
#25			(* IF selection >= 0 *)
#26			LD		selection	{L:20}
(*) UNDEF
A0010228  F1F0C00B		mov d15, d12

#27			GE		0	{L:20}
(*) INT
A001022C  8000003B		mov d8, #0
A0010230  F1408F0B		ge d15, d15, d8

#28			JMPCN	$label1	{L:20}
(-) BOOL
A0010234  001E0FDF		jeq d15, #0, #0x001E ; JUMP 0xA0010270

#29		
#30			(* THEN *)
#31		
#32				(* ReadCommand := RBit(digitalInputs, TO_UINT(selection)); *)
#33				LD		selection	{L:22}
(*) UNDEF
A0010238  F1F0C00B		mov d15, d12

#34				TO_UINT	{L:22}
(*) INT
#35				ST		$$TMP0	{L:22}
(*) UINT
A001023C  F000A001		mov.aa a15, sp
A0010240  0880FF89		st.h [a15], d15

#36				LD		digitalInputs	{L:22}
(*) UNDEF
A0010244  F1F0B00B		mov d15, d11

#37				RBit		$$TMP0	{L:22}
(-) UINT
A0010248  F000A001		mov.aa a15, sp
A001024C  08C0F509		ld.hu d5, [a15]
A0010250  41F0F00B		mov d4, d15
A0010254  0382006D		call #0x000382 ; CALL 0xA0010958
A0010258  F1F0200B		mov d15, d2

#38				ST		ReadCommand	{L:22}
(*) BOOL
A001025C  21F0F00B		mov d2, d15

#39		
#40				(* RETURN *)
#41				RET
(-) BOOL
A0010260  FA001091		movh.a a15, #0xA001 ; 0xA00102BC
A0010264  A03CFFD9		lea a15,[a15]0x02BC
A0010268  0000000D		nop
A001026C  00300F2D		ji a15

#42		
#43		$label1:
#44			(* END_IF *)
#45		
#46		
#47			(* IF selection = -2) AND (nBitRemoteCommand >= 0 *)
#48			LD		nBitRemoteCommand	{L:30}
(*) UNDEF
A0010270  F000C001		mov.aa a15, a12
A0010274  08C0FF09		ld.hu d15, [a15]

#49			GE		0	{L:30}
(*) UINT
A0010278  8000003B		mov d8, #0
A001027C  F1508F0B		ge.u d15, d15, d8

#50			AND(		selection	{L:30}
(*) BOOL
A0010280  F53CAF89		st.w [-sp]4, d15 
A0010284  F1F0C00B		mov d15, d12

#51			EQ		-2	{L:30}
(*) INT
A0010288  8FFFE03B		mov d8, #-2
A001028C  F1008F0B		eq d15, d15, d8

#52			)	{L:30}
(*) BOOL
A0010290  01F0F00B		mov d0, d15
A0010294  0104AF09		ld.w d15, [sp+]4
A0010298  F0800F0F		and d15, d15, d0

#53			JMPCN	$label2	{L:30}
(-) BOOL
A001029C  00100FDF		jeq d15, #0, #0x0010 ; JUMP 0xA00102BC

#54		
#55			(* THEN *)
#56		
#57				(* ReadCommand := RBit(remoteCommand, nBitRemoteCommand); *)
#58				LD		remoteCommand	{L:32}
(*) UNDEF
A00102A0  F1F0D00B		mov d15, d13

#59				RBit		nBitRemoteCommand	{L:32}
(-) UINT
A00102A4  F000C001		mov.aa a15, a12
A00102A8  08C0F509		ld.hu d5, [a15]
A00102AC  41F0F00B		mov d4, d15
A00102B0  0354006D		call #0x000354 ; CALL 0xA0010958
A00102B4  F1F0200B		mov d15, d2

#60				ST		ReadCommand	{L:32}
(*) BOOL
A00102B8  21F0F00B		mov d2, d15

#61		
#62				(* RETURN *)
#63				RET
(-) BOOL
A00102BC  800040BB		mov.u d8, #4
A00102C0  E6308001		mov.a a14, d8
A00102C4  A010EA01		add.a sp, sp, a14

A00102C8  0180000D		ret

END_FUNCTION
**************************************************
	List function: ReadCommandAnd
**************************************************

FUNCTION ReadCommandAnd : BOOL

{ DE:"Digital command management (AND)

3 sources are available:
digital parameter
digital input
remote command (typically fieldbus)

there is a mask that enables the sources:
bit0= digital parameter, bit1= digital input, bit2=remote command

the function performs AND between the sources (bit0,1,2) which bit is set TRUE.

Note: if bit0=bit1=bit2=0 the function return TRUE
" }

	VAR_INPUT
	digpar : BOOL; { DE:"digital parameter" } 
	digitalInputs : UINT; { DE:"digital inputs bitword" } 
	nBitDigitalInputs : INT; { DE:"digital input bit number" } 
	remoteCommand : UINT; { DE:"remote command bitword" } 
	nBitRemoteCommand : UINT; { DE:"remote command bit" } 
	enableMask : UINT; { DE:"enable mask: bit0=dig par, bit1=dig input, bit2=remote command)" } 
	END_VAR

	*** Function data allocation

	Par digpar: REGISTER d4
	Par digitalInputs: REGISTER d5
	Par nBitDigitalInputs: REGISTER d6
	Par remoteCommand: REGISTER d7
	Par nBitRemoteCommand: LOCAL STACK FRAME AT 0(sp)
	Par enableMask: CALLER STACK FRAME AT 4(sp)

A00102CC  A1F0400B		mov d10, d4
A00102D0  B1F0500B		mov d11, d5
A00102D4  C1F0600B		mov d12, d6
A00102D8  D1F0700B		mov d13, d7
A00102DC  C000A001		mov.aa a12, sp
A00102E0  800040BB		mov.u d8, #4
A00102E4  E6308001		mov.a a14, d8
A00102E8  A020EA01		sub.a sp, sp, a14

#0		{SRC:ReadCommandAnd}
#1		
#2		
#3			(* IF enableMask AND 1) <> 0 *)
#4			LD		enableMask	{L:3}
(*) UNDEF
A00102EC  800040BB		mov.u d8, #0x4
A00102F0  F600C801		addsc.a a15, a12, d8, #0
A00102F4  08C0FF09		ld.hu d15, [a15]

#5			AND		1	{L:3}
(*) UINT
A00102F8  8000103B		mov d8, #1
A00102FC  F0808F0F		and d15, d15, d8

#6			NE		0	{L:3}
(*) UINT
A0010300  8000003B		mov d8, #0
A0010304  F1108F0B		ne d15, d15, d8

#7			JMPCN	$label0	{L:3}
(-) BOOL
A0010308  00180FDF		jeq d15, #0, #0x0018 ; JUMP 0xA0010338

#8		
#9			(* THEN *)
#10		
#11		
#12				(* IF digpar *)
#13				LD		digpar	{L:4}
(*) UNDEF
A001030C  F1F0A00B		mov d15, d10

#14				NOT	{L:4}
(*) BOOL
A0010310  8000103B		mov d8, #1
A0010314  9000003B		mov d9, #0
A0010318  FF40892B		sel d15, d15, d9, d8

#15				JMPCN	$label1	{L:4}
(-) BOOL
A001031C  000E0FDF		jeq d15, #0, #0x000E ; JUMP 0xA0010338

#16		
#17				(* THEN *)
#18		
#19					(* ReadCommandAnd := FALSE; *)
#20					LD		FALSE	{L:5}
(*) UNDEF
A0010320  F000003B		mov d15, #0

#21					ST		ReadCommandAnd	{L:5}
(*) BOOL
A0010324  21F0F00B		mov d2, d15

#22		
#23					(* RETURN *)
#24					RET
(-) BOOL
A0010328  FA001091		movh.a a15, #0xA001 ; 0xA0010430
A001032C  0070FFD9		lea a15,[a15]0x0430
A0010330  0000000D		nop
A0010334  00300F2D		ji a15

#25		
#26		$label1:
#27				(* END_IF *)
#28		
#29		$label0:
#30			(* END_IF *)
#31		
#32		
#33			(* IF enableMask AND 2) <> 0 *)
#34			LD		enableMask	{L:11}
(*) UNDEF
A0010338  800040BB		mov.u d8, #0x4
A001033C  F600C801		addsc.a a15, a12, d8, #0
A0010340  08C0FF09		ld.hu d15, [a15]

#35			AND		2	{L:11}
(*) UINT
A0010344  8000203B		mov d8, #2
A0010348  F0808F0F		and d15, d15, d8

#36			NE		0	{L:11}
(*) UINT
A001034C  8000003B		mov d8, #0
A0010350  F1108F0B		ne d15, d15, d8

#37			JMPCN	$label2	{L:11}
(-) BOOL
A0010354  00300FDF		jeq d15, #0, #0x0030 ; JUMP 0xA00103B4

#38		
#39			(* THEN *)
#40		
#41		
#42				(* IF nBitDigitalInputs >= 0 *)
#43				LD		nBitDigitalInputs	{L:12}
(*) UNDEF
A0010358  F1F0C00B		mov d15, d12

#44				GE		0	{L:12}
(*) INT
A001035C  8000003B		mov d8, #0
A0010360  F1408F0B		ge d15, d15, d8

#45				JMPCN	$label3	{L:12}
(-) BOOL
A0010364  00280FDF		jeq d15, #0, #0x0028 ; JUMP 0xA00103B4

#46		
#47				(* THEN *)
#48		
#49		
#50					(* IF digitalInputs, TO_UINT(nBitDigitalInputs)) *)
#51					LD		nBitDigitalInputs	{L:13}
(*) UNDEF
A0010368  F1F0C00B		mov d15, d12

#52					TO_UINT	{L:13}
(*) INT
#53					ST		$$TMP0	{L:13}
(*) UINT
A001036C  F000A001		mov.aa a15, sp
A0010370  0880FF89		st.h [a15], d15

#54					LD		digitalInputs	{L:13}
(*) UNDEF
A0010374  F1F0B00B		mov d15, d11

#55					RBit		$$TMP0	{L:13}
(-) UINT
A0010378  F000A001		mov.aa a15, sp
A001037C  08C0F509		ld.hu d5, [a15]
A0010380  41F0F00B		mov d4, d15
A0010384  02EA006D		call #0x0002EA ; CALL 0xA0010958
A0010388  F1F0200B		mov d15, d2

#56					NOT	{L:13}
(*) BOOL
A001038C  8000103B		mov d8, #1
A0010390  9000003B		mov d9, #0
A0010394  FF40892B		sel d15, d15, d9, d8

#57					JMPCN	$label4	{L:13}
(-) BOOL
A0010398  000E0FDF		jeq d15, #0, #0x000E ; JUMP 0xA00103B4

#58		
#59					(* THEN *)
#60		
#61						(* ReadCommandAnd := FALSE; *)
#62						LD		FALSE	{L:14}
(*) UNDEF
A001039C  F000003B		mov d15, #0

#63						ST		ReadCommandAnd	{L:14}
(*) BOOL
A00103A0  21F0F00B		mov d2, d15

#64		
#65						(* RETURN *)
#66						RET
(-) BOOL
A00103A4  FA001091		movh.a a15, #0xA001 ; 0xA0010430
A00103A8  0070FFD9		lea a15,[a15]0x0430
A00103AC  0000000D		nop
A00103B0  00300F2D		ji a15

#67		
#68		$label4:
#69					(* END_IF *)
#70		
#71		$label3:
#72				(* END_IF *)
#73		
#74		$label2:
#75			(* END_IF *)
#76		
#77		
#78			(* IF enableMask AND 4) <> 0 *)
#79			LD		enableMask	{L:21}
(*) UNDEF
A00103B4  800040BB		mov.u d8, #0x4
A00103B8  F600C801		addsc.a a15, a12, d8, #0
A00103BC  08C0FF09		ld.hu d15, [a15]

#80			AND		4	{L:21}
(*) UINT
A00103C0  8000403B		mov d8, #4
A00103C4  F0808F0F		and d15, d15, d8

#81			NE		0	{L:21}
(*) UINT
A00103C8  8000003B		mov d8, #0
A00103CC  F1108F0B		ne d15, d15, d8

#82			JMPCN	$label5	{L:21}
(-) BOOL
A00103D0  002C0FDF		jeq d15, #0, #0x002C ; JUMP 0xA0010428

#83		
#84			(* THEN *)
#85		
#86		
#87				(* IF nBitRemoteCommand >= 0 *)
#88				LD		nBitRemoteCommand	{L:22}
(*) UNDEF
A00103D4  F000C001		mov.aa a15, a12
A00103D8  08C0FF09		ld.hu d15, [a15]

#89				GE		0	{L:22}
(*) UINT
A00103DC  8000003B		mov d8, #0
A00103E0  F1508F0B		ge.u d15, d15, d8

#90				JMPCN	$label6	{L:22}
(-) BOOL
A00103E4  00220FDF		jeq d15, #0, #0x0022 ; JUMP 0xA0010428

#91		
#92				(* THEN *)
#93		
#94		
#95					(* IF remoteCommand, nBitRemoteCommand) *)
#96					LD		remoteCommand	{L:23}
(*) UNDEF
A00103E8  F1F0D00B		mov d15, d13

#97					RBit		nBitRemoteCommand	{L:23}
(-) UINT
A00103EC  F000C001		mov.aa a15, a12
A00103F0  08C0F509		ld.hu d5, [a15]
A00103F4  41F0F00B		mov d4, d15
A00103F8  02B0006D		call #0x0002B0 ; CALL 0xA0010958
A00103FC  F1F0200B		mov d15, d2

#98					NOT	{L:23}
(*) BOOL
A0010400  8000103B		mov d8, #1
A0010404  9000003B		mov d9, #0
A0010408  FF40892B		sel d15, d15, d9, d8

#99					JMPCN	$label7	{L:23}
(-) BOOL
A001040C  000E0FDF		jeq d15, #0, #0x000E ; JUMP 0xA0010428

#100		
#101					(* THEN *)
#102		
#103						(* ReadCommandAnd := FALSE; *)
#104						LD		FALSE	{L:24}
(*) UNDEF
A0010410  F000003B		mov d15, #0

#105						ST		ReadCommandAnd	{L:24}
(*) BOOL
A0010414  21F0F00B		mov d2, d15

#106		
#107						(* RETURN *)
#108						RET
(-) BOOL
A0010418  FA001091		movh.a a15, #0xA001 ; 0xA0010430
A001041C  0070FFD9		lea a15,[a15]0x0430
A0010420  0000000D		nop
A0010424  00300F2D		ji a15

#109		
#110		$label7:
#111					(* END_IF *)
#112		
#113		$label6:
#114				(* END_IF *)
#115		
#116		$label5:
#117			(* END_IF *)
#118		
#119			(* ReadCommandAnd := TRUE; *)
#120			LD		TRUE	{L:33}
(*) UNDEF
A0010428  F000103B		mov d15, #1

#121			ST		ReadCommandAnd	{L:33}
(*) BOOL
A001042C  21F0F00B		mov d2, d15

A0010430  800040BB		mov.u d8, #4
A0010434  E6308001		mov.a a14, d8
A0010438  A010EA01		add.a sp, sp, a14

A001043C  0180000D		ret

END_FUNCTION
**************************************************
	List function: ReadCommandOr
**************************************************

FUNCTION ReadCommandOr : BOOL

{ DE:"Digital command management (OR)
3 sources are available:
digital parameter
digital input
remote command (typically fieldbus)

there is a mask that enables the sources:
bit0= digital parameter, bit1= digital input, bit2=remote command

the function performs and OR between the sources (bit0,1,2) which bit is set TRUE.

Note: if bit0=bit1=bit2=0 the function return FALSE
" }

	VAR_INPUT
	digpar : BOOL; { DE:"digital parameter" } 
	digitalInputs : UINT; { DE:"digital inputs bitword" } 
	nBitDigitalInputs : INT; { DE:"digital input bit number" } 
	remoteCommand : UINT; { DE:"remote command bitword" } 
	nBitRemoteCommand : UINT; { DE:"remote command bit" } 
	enableMask : UINT; { DE:"enable mask: bit0=dig par, bit1=dig input, bit2=remote command)" } 
	END_VAR

	*** Function data allocation

	Par digpar: REGISTER d4
	Par digitalInputs: REGISTER d5
	Par nBitDigitalInputs: REGISTER d6
	Par remoteCommand: REGISTER d7
	Par nBitRemoteCommand: LOCAL STACK FRAME AT 0(sp)
	Par enableMask: CALLER STACK FRAME AT 4(sp)

A0010440  A1F0400B		mov d10, d4
A0010444  B1F0500B		mov d11, d5
A0010448  C1F0600B		mov d12, d6
A001044C  D1F0700B		mov d13, d7
A0010450  C000A001		mov.aa a12, sp
A0010454  800040BB		mov.u d8, #4
A0010458  E6308001		mov.a a14, d8
A001045C  A020EA01		sub.a sp, sp, a14

#0		{SRC:ReadCommandOr}
#1		
#2		
#3			(* IF enableMask AND 1) <> 0 *)
#4			LD		enableMask	{L:3}
(*) UNDEF
A0010460  800040BB		mov.u d8, #0x4
A0010464  F600C801		addsc.a a15, a12, d8, #0
A0010468  08C0FF09		ld.hu d15, [a15]

#5			AND		1	{L:3}
(*) UINT
A001046C  8000103B		mov d8, #1
A0010470  F0808F0F		and d15, d15, d8

#6			NE		0	{L:3}
(*) UINT
A0010474  8000003B		mov d8, #0
A0010478  F1108F0B		ne d15, d15, d8

#7			JMPCN	$label0	{L:3}
(-) BOOL
A001047C  00120FDF		jeq d15, #0, #0x0012 ; JUMP 0xA00104A0

#8		
#9			(* THEN *)
#10		
#11		
#12				(* IF digpar *)
#13				LD		digpar	{L:4}
(*) UNDEF
A0010480  F1F0A00B		mov d15, d10

#14				JMPCN	$label1	{L:4}
(-) BOOL
A0010484  000E0FDF		jeq d15, #0, #0x000E ; JUMP 0xA00104A0

#15		
#16				(* THEN *)
#17		
#18					(* ReadCommandOr := TRUE; *)
#19					LD		TRUE	{L:5}
(*) UNDEF
A0010488  F000103B		mov d15, #1

#20					ST		ReadCommandOr	{L:5}
(*) BOOL
A001048C  21F0F00B		mov d2, d15

#21		
#22					(* RETURN *)
#23					RET
(-) BOOL
A0010490  FA001091		movh.a a15, #0xA001 ; 0xA0010580
A0010494  6040FFD9		lea a15,[a15]0x0580
A0010498  0000000D		nop
A001049C  00300F2D		ji a15

#24		
#25		$label1:
#26				(* END_IF *)
#27		
#28		$label0:
#29			(* END_IF *)
#30		
#31		
#32			(* IF enableMask AND 2) <> 0 *)
#33			LD		enableMask	{L:11}
(*) UNDEF
A00104A0  800040BB		mov.u d8, #0x4
A00104A4  F600C801		addsc.a a15, a12, d8, #0
A00104A8  08C0FF09		ld.hu d15, [a15]

#34			AND		2	{L:11}
(*) UINT
A00104AC  8000203B		mov d8, #2
A00104B0  F0808F0F		and d15, d15, d8

#35			NE		0	{L:11}
(*) UINT
A00104B4  8000003B		mov d8, #0
A00104B8  F1108F0B		ne d15, d15, d8

#36			JMPCN	$label2	{L:11}
(-) BOOL
A00104BC  002A0FDF		jeq d15, #0, #0x002A ; JUMP 0xA0010510

#37		
#38			(* THEN *)
#39		
#40		
#41				(* IF nBitDigitalInputs >= 0 *)
#42				LD		nBitDigitalInputs	{L:12}
(*) UNDEF
A00104C0  F1F0C00B		mov d15, d12

#43				GE		0	{L:12}
(*) INT
A00104C4  8000003B		mov d8, #0
A00104C8  F1408F0B		ge d15, d15, d8

#44				JMPCN	$label3	{L:12}
(-) BOOL
A00104CC  00220FDF		jeq d15, #0, #0x0022 ; JUMP 0xA0010510

#45		
#46				(* THEN *)
#47		
#48		
#49					(* IF digitalInputs, TO_UINT(nBitDigitalInputs *)
#50					LD		nBitDigitalInputs	{L:13}
(*) UNDEF
A00104D0  F1F0C00B		mov d15, d12

#51					TO_UINT	{L:13}
(*) INT
#52					ST		$$TMP0	{L:13}
(*) UINT
A00104D4  F000A001		mov.aa a15, sp
A00104D8  0880FF89		st.h [a15], d15

#53					LD		digitalInputs	{L:13}
(*) UNDEF
A00104DC  F1F0B00B		mov d15, d11

#54					RBit		$$TMP0	{L:13}
(-) UINT
A00104E0  F000A001		mov.aa a15, sp
A00104E4  08C0F509		ld.hu d5, [a15]
A00104E8  41F0F00B		mov d4, d15
A00104EC  0236006D		call #0x000236 ; CALL 0xA0010958
A00104F0  F1F0200B		mov d15, d2

#55					JMPCN	$label4	{L:13}
(-) BOOL
A00104F4  000E0FDF		jeq d15, #0, #0x000E ; JUMP 0xA0010510

#56		
#57					(* THEN *)
#58		
#59						(* ReadCommandOr := TRUE; *)
#60						LD		TRUE	{L:14}
(*) UNDEF
A00104F8  F000103B		mov d15, #1

#61						ST		ReadCommandOr	{L:14}
(*) BOOL
A00104FC  21F0F00B		mov d2, d15

#62		
#63						(* RETURN *)
#64						RET
(-) BOOL
A0010500  FA001091		movh.a a15, #0xA001 ; 0xA0010580
A0010504  6040FFD9		lea a15,[a15]0x0580
A0010508  0000000D		nop
A001050C  00300F2D		ji a15

#65		
#66		$label4:
#67					(* END_IF *)
#68		
#69		$label3:
#70				(* END_IF *)
#71		
#72		$label2:
#73			(* END_IF *)
#74		
#75		
#76			(* IF enableMask AND 4) <> 0 *)
#77			LD		enableMask	{L:21}
(*) UNDEF
A0010510  800040BB		mov.u d8, #0x4
A0010514  F600C801		addsc.a a15, a12, d8, #0
A0010518  08C0FF09		ld.hu d15, [a15]

#78			AND		4	{L:21}
(*) UINT
A001051C  8000403B		mov d8, #4
A0010520  F0808F0F		and d15, d15, d8

#79			NE		0	{L:21}
(*) UINT
A0010524  8000003B		mov d8, #0
A0010528  F1108F0B		ne d15, d15, d8

#80			JMPCN	$label5	{L:21}
(-) BOOL
A001052C  00260FDF		jeq d15, #0, #0x0026 ; JUMP 0xA0010578

#81		
#82			(* THEN *)
#83		
#84		
#85				(* IF nBitRemoteCommand >= 0 *)
#86				LD		nBitRemoteCommand	{L:22}
(*) UNDEF
A0010530  F000C001		mov.aa a15, a12
A0010534  08C0FF09		ld.hu d15, [a15]

#87				GE		0	{L:22}
(*) UINT
A0010538  8000003B		mov d8, #0
A001053C  F1508F0B		ge.u d15, d15, d8

#88				JMPCN	$label6	{L:22}
(-) BOOL
A0010540  001C0FDF		jeq d15, #0, #0x001C ; JUMP 0xA0010578

#89		
#90				(* THEN *)
#91		
#92		
#93					(* IF remoteCommand, nBitRemoteCommand *)
#94					LD		remoteCommand	{L:23}
(*) UNDEF
A0010544  F1F0D00B		mov d15, d13

#95					RBit		nBitRemoteCommand	{L:23}
(-) UINT
A0010548  F000C001		mov.aa a15, a12
A001054C  08C0F509		ld.hu d5, [a15]
A0010550  41F0F00B		mov d4, d15
A0010554  0202006D		call #0x000202 ; CALL 0xA0010958
A0010558  F1F0200B		mov d15, d2

#96					JMPCN	$label7	{L:23}
(-) BOOL
A001055C  000E0FDF		jeq d15, #0, #0x000E ; JUMP 0xA0010578

#97		
#98					(* THEN *)
#99		
#100						(* ReadCommandOr := TRUE; *)
#101						LD		TRUE	{L:24}
(*) UNDEF
A0010560  F000103B		mov d15, #1

#102						ST		ReadCommandOr	{L:24}
(*) BOOL
A0010564  21F0F00B		mov d2, d15

#103		
#104						(* RETURN *)
#105						RET
(-) BOOL
A0010568  FA001091		movh.a a15, #0xA001 ; 0xA0010580
A001056C  6040FFD9		lea a15,[a15]0x0580
A0010570  0000000D		nop
A0010574  00300F2D		ji a15

#106		
#107		$label7:
#108					(* END_IF *)
#109		
#110		$label6:
#111				(* END_IF *)
#112		
#113		$label5:
#114			(* END_IF *)
#115		
#116			(* ReadCommandOr := FALSE; *)
#117			LD		FALSE	{L:31}
(*) UNDEF
A0010578  F000003B		mov d15, #0

#118			ST		ReadCommandOr	{L:31}
(*) BOOL
A001057C  21F0F00B		mov d2, d15

A0010580  800040BB		mov.u d8, #4
A0010584  E6308001		mov.a a14, d8
A0010588  A010EA01		add.a sp, sp, a14

A001058C  0180000D		ret

END_FUNCTION
**************************************************
	List function: _GeneralVersion
**************************************************

FUNCTION _GeneralVersion : UDINT

{ DE:"LIBRARY: General

Rev.02.00.00    10/06/2008


library with general functions and FB:
bits reading from a word;
bits writing in a word;
bit to word;
word to bit;
byte to bit;
word to byte;
two bytes to word;
two words to dword;
four bytes to dword;

Note:
no global vars are used, so that this library can be used regardless the drive FW version" }

	VAR_INPUT
	in : BOOL; 
	END_VAR

	*** Function data allocation

	Par in: REGISTER d4

#0		{SRC:_GeneralVersion}
#1		
#2		
#3			LD		in
(*) UNDEF
A0010590  F1F0400B		mov d15, d4

#4			JMPC	l0_Version
(-) BOOL
A0010594  800E0FDF		jne d15, #0, #0x000E ; JUMP 0xA00105B0

#5		
#6			LD		0
(*) UNDEF
A0010598  F000003B		mov d15, #0

#7			ST		_GeneralVersion
(*) USINT
A001059C  21F0F00B		mov d2, d15

#8		
#9			RET
(-) USINT
A00105A0  FA001091		movh.a a15, #0xA001 ; 0xA00105B8
A00105A4  6078FFD9		lea a15,[a15]0x05B8
A00105A8  0000000D		nop
A00105AC  00300F2D		ji a15

#10		
#11		l0_Version:
#12		
#13			(*	Indice di revisione.						*)
#14			(*	L'indice si legge nella seguente maniera:	*)
#15			(*	XXYYZZ => XX.YY.ZZ 							*)
#16			(*	XX = Revisione								*)
#17			(*	YY = Sotto revisione						*)
#18			(*	ZZ = Correzione								*)
#19		
#20			LD		020000
(*) UNDEF
A00105B0  F4E2003B		mov d15, #20000

#21			ST		_GeneralVersion
(*) UINT
A00105B4  21F0F00B		mov d2, d15

A00105B8  0180000D		ret

END_FUNCTION
**************************************************
	List function: BitToWord
**************************************************

FUNCTION BitToWord : UINT

{ DE:"Compose a word from 16 bits
The inputs are aligned according bit number. 
i.e.
        b0  in position 0
        b1  in position 1
        ...
        b15 in position 15" }

	VAR_INPUT
	b0 : BOOL; 
	b1 : BOOL; 
	b2 : BOOL; 
	b3 : BOOL; 
	b4 : BOOL; 
	b5 : BOOL; 
	b6 : BOOL; 
	b7 : BOOL; 
	b8 : BOOL; 
	b9 : BOOL; 
	b10 : BOOL; 
	b11 : BOOL; 
	b12 : BOOL; 
	b13 : BOOL; 
	b14 : BOOL; 
	b15 : BOOL; 
	END_VAR

	*** Function data allocation

	Par b0: REGISTER d4
	Par b1: REGISTER d5
	Par b2: REGISTER d6
	Par b3: REGISTER d7
	Par b4: LOCAL STACK FRAME AT 0(sp)
	Par b5: CALLER STACK FRAME AT 4(sp)
	Par b6: CALLER STACK FRAME AT 8(sp)
	Par b7: CALLER STACK FRAME AT 12(sp)
	Par b8: CALLER STACK FRAME AT 16(sp)
	Par b9: CALLER STACK FRAME AT 20(sp)
	Par b10: CALLER STACK FRAME AT 24(sp)
	Par b11: CALLER STACK FRAME AT 28(sp)
	Par b12: CALLER STACK FRAME AT 32(sp)
	Par b13: CALLER STACK FRAME AT 36(sp)
	Par b14: CALLER STACK FRAME AT 40(sp)
	Par b15: CALLER STACK FRAME AT 44(sp)

A00105BC  C000A001		mov.aa a12, sp

#0		{SRC:BitToWord}
#1		
#2			LD		b15
(*) UNDEF
A00105C0  8002C0BB		mov.u d8, #0x2C
A00105C4  F600C801		addsc.a a15, a12, d8, #0
A00105C8  0000FF19		ld.w d15, [a15]

#3			TO_UINT
(*) BOOL
#4			SHL		15
(*) UINT
A00105CC  F000FF8F		sh d15, d15, #15

#5			ST		BitToWord
(*) UINT
A00105D0  21F0F00B		mov d2, d15

#6		
#7			LD		b14
(*) UNDEF
A00105D4  800280BB		mov.u d8, #0x28
A00105D8  F600C801		addsc.a a15, a12, d8, #0
A00105DC  0000FF19		ld.w d15, [a15]

#8			TO_UINT
(*) BOOL
#9			SHL		14
(*) UINT
A00105E0  F000EF8F		sh d15, d15, #14

#10			ADD		BitToWord
(*) UINT
A00105E4  F0002F0B		add d15, d15, d2

#11			ST		BitToWord
(*) UINT
A00105E8  21F0F00B		mov d2, d15

#12		
#13			LD		b13
(*) UNDEF
A00105EC  800240BB		mov.u d8, #0x24
A00105F0  F600C801		addsc.a a15, a12, d8, #0
A00105F4  0000FF19		ld.w d15, [a15]

#14			TO_UINT
(*) BOOL
#15			SHL		13
(*) UINT
A00105F8  F000DF8F		sh d15, d15, #13

#16			ADD		BitToWord
(*) UINT
A00105FC  F0002F0B		add d15, d15, d2

#17			ST		BitToWord
(*) UINT
A0010600  21F0F00B		mov d2, d15

#18		
#19			LD		b12
(*) UNDEF
A0010604  800200BB		mov.u d8, #0x20
A0010608  F600C801		addsc.a a15, a12, d8, #0
A001060C  0000FF19		ld.w d15, [a15]

#20			TO_UINT
(*) BOOL
#21			SHL		12
(*) UINT
A0010610  F000CF8F		sh d15, d15, #12

#22			ADD		BitToWord
(*) UINT
A0010614  F0002F0B		add d15, d15, d2

#23			ST		BitToWord
(*) UINT
A0010618  21F0F00B		mov d2, d15

#24		
#25			LD		b11
(*) UNDEF
A001061C  8001C0BB		mov.u d8, #0x1C
A0010620  F600C801		addsc.a a15, a12, d8, #0
A0010624  0000FF19		ld.w d15, [a15]

#26			TO_UINT
(*) BOOL
#27			SHL		11
(*) UINT
A0010628  F000BF8F		sh d15, d15, #11

#28			ADD		BitToWord
(*) UINT
A001062C  F0002F0B		add d15, d15, d2

#29			ST		BitToWord
(*) UINT
A0010630  21F0F00B		mov d2, d15

#30		
#31			LD		b10
(*) UNDEF
A0010634  800180BB		mov.u d8, #0x18
A0010638  F600C801		addsc.a a15, a12, d8, #0
A001063C  0000FF19		ld.w d15, [a15]

#32			TO_UINT
(*) BOOL
#33			SHL		10
(*) UINT
A0010640  F000AF8F		sh d15, d15, #10

#34			ADD		BitToWord
(*) UINT
A0010644  F0002F0B		add d15, d15, d2

#35			ST		BitToWord
(*) UINT
A0010648  21F0F00B		mov d2, d15

#36		
#37			LD		b9
(*) UNDEF
A001064C  800140BB		mov.u d8, #0x14
A0010650  F600C801		addsc.a a15, a12, d8, #0
A0010654  0000FF19		ld.w d15, [a15]

#38			TO_UINT
(*) BOOL
#39			SHL		9
(*) UINT
A0010658  F0009F8F		sh d15, d15, #9

#40			ADD		BitToWord
(*) UINT
A001065C  F0002F0B		add d15, d15, d2

#41			ST		BitToWord
(*) UINT
A0010660  21F0F00B		mov d2, d15

#42		
#43			LD		b8
(*) UNDEF
A0010664  800100BB		mov.u d8, #0x10
A0010668  F600C801		addsc.a a15, a12, d8, #0
A001066C  0000FF19		ld.w d15, [a15]

#44			TO_UINT
(*) BOOL
#45			SHL		8
(*) UINT
A0010670  F0008F8F		sh d15, d15, #8

#46			ADD		BitToWord
(*) UINT
A0010674  F0002F0B		add d15, d15, d2

#47			ST		BitToWord
(*) UINT
A0010678  21F0F00B		mov d2, d15

#48		
#49			LD		b7
(*) UNDEF
A001067C  8000C0BB		mov.u d8, #0xC
A0010680  F600C801		addsc.a a15, a12, d8, #0
A0010684  0000FF19		ld.w d15, [a15]

#50			TO_UINT
(*) BOOL
#51			SHL		7
(*) UINT
A0010688  F0007F8F		sh d15, d15, #7

#52			ADD		BitToWord
(*) UINT
A001068C  F0002F0B		add d15, d15, d2

#53			ST		BitToWord
(*) UINT
A0010690  21F0F00B		mov d2, d15

#54		
#55			LD		b6
(*) UNDEF
A0010694  800080BB		mov.u d8, #0x8
A0010698  F600C801		addsc.a a15, a12, d8, #0
A001069C  0000FF19		ld.w d15, [a15]

#56			TO_UINT
(*) BOOL
#57			SHL		6
(*) UINT
A00106A0  F0006F8F		sh d15, d15, #6

#58			ADD		BitToWord
(*) UINT
A00106A4  F0002F0B		add d15, d15, d2

#59			ST		BitToWord
(*) UINT
A00106A8  21F0F00B		mov d2, d15

#60		
#61			LD		b5
(*) UNDEF
A00106AC  800040BB		mov.u d8, #0x4
A00106B0  F600C801		addsc.a a15, a12, d8, #0
A00106B4  0000FF19		ld.w d15, [a15]

#62			TO_UINT
(*) BOOL
#63			SHL		5
(*) UINT
A00106B8  F0005F8F		sh d15, d15, #5

#64			ADD		BitToWord
(*) UINT
A00106BC  F0002F0B		add d15, d15, d2

#65			ST		BitToWord
(*) UINT
A00106C0  21F0F00B		mov d2, d15

#66		
#67			LD		b4
(*) UNDEF
A00106C4  F000C001		mov.aa a15, a12
A00106C8  0000FF19		ld.w d15, [a15]

#68			TO_UINT
(*) BOOL
#69			SHL		4
(*) UINT
A00106CC  F0004F8F		sh d15, d15, #4

#70			ADD		BitToWord
(*) UINT
A00106D0  F0002F0B		add d15, d15, d2

#71			ST		BitToWord
(*) UINT
A00106D4  21F0F00B		mov d2, d15

#72		
#73			LD		b3
(*) UNDEF
A00106D8  F1F0700B		mov d15, d7

#74			TO_UINT
(*) BOOL
#75			SHL		3
(*) UINT
A00106DC  F0003F8F		sh d15, d15, #3

#76			ADD		BitToWord
(*) UINT
A00106E0  F0002F0B		add d15, d15, d2

#77			ST		BitToWord
(*) UINT
A00106E4  21F0F00B		mov d2, d15

#78		
#79			LD		b2
(*) UNDEF
A00106E8  F1F0600B		mov d15, d6

#80			TO_UINT
(*) BOOL
#81			SHL		2
(*) UINT
A00106EC  F0002F8F		sh d15, d15, #2

#82			ADD		BitToWord
(*) UINT
A00106F0  F0002F0B		add d15, d15, d2

#83			ST		BitToWord
(*) UINT
A00106F4  21F0F00B		mov d2, d15

#84		
#85			LD		b1
(*) UNDEF
A00106F8  F1F0500B		mov d15, d5

#86			TO_UINT
(*) BOOL
#87			SHL		1
(*) UINT
A00106FC  F0001F8F		sh d15, d15, #1

#88			ADD		BitToWord
(*) UINT
A0010700  F0002F0B		add d15, d15, d2

#89			ST		BitToWord
(*) UINT
A0010704  21F0F00B		mov d2, d15

#90		
#91			LD		b0
(*) UNDEF
A0010708  F1F0400B		mov d15, d4

#92			TO_UINT
(*) BOOL
#93			ADD		BitToWord
(*) UINT
A001070C  F0002F0B		add d15, d15, d2

#94			ST		BitToWord
(*) UINT
A0010710  21F0F00B		mov d2, d15

A0010714  0180000D		ret

END_FUNCTION
**************************************************
	List function: Line
**************************************************

FUNCTION Line : DINT

{ DE:"02/01/2001			by SSS
The function return the y(x) value. The function is the linear inter(extra)polation
of the line passing through two points.
The points are defined with the following coordinates:
(xIni, yIni), (xEnd, yEnd).

The returned value is:
Result=yIni+(yEnd-yIni)/(xEnd-xIni)*(x-xIni)" }

	VAR_INPUT
	inX : DINT; { DE:"input X [cnts]" } 
	xIni : DINT; { DE:"initial X [cnts]" } 
	yIni : DINT; { DE:"initial Y [cnts]" } 
	xEnd : DINT; { DE:"final X [cnts]" } 
	yEnd : DINT; { DE:"final Y [cnts]" } 
	END_VAR

	*** Function data allocation

	Par inX: REGISTER d4
	Par xIni: REGISTER d5
	Par yIni: REGISTER d6
	Par xEnd: REGISTER d7
	Par yEnd: LOCAL STACK FRAME AT 0(sp)

A0010718  C000A001		mov.aa a12, sp

#0		{SRC:Line}
#1		
#2			LD		inX
(*) UNDEF
A001071C  F1F0400B		mov d15, d4

#3			SUB		xIni
(*) DINT
A0010720  F0805F0B		sub d15, d15, d5

#4			MUL(	yEnd
(*) DINT
A0010724  F53CAF89		st.w [-sp]4, d15 
A0010728  F000C001		mov.aa a15, a12
A001072C  0000FF19		ld.w d15, [a15]

#5			SUB		yIni
(*) DINT
A0010730  F0806F0B		sub d15, d15, d6

#6			)
(*) DINT
A0010734  01F0F00B		mov d0, d15
A0010738  0104AF09		ld.w d15, [sp+]4
A001073C  F00A0F73		mul d15, d15, d0

#7			DIV(	xEnd
(*) DINT
A0010740  F53CAF89		st.w [-sp]4, d15 
A0010744  F1F0700B		mov d15, d7

#8			SUB		xIni
(*) DINT
A0010748  F0805F0B		sub d15, d15, d5

#9			)
(*) DINT
A001074C  01F0F00B		mov d0, d15
A0010750  0104AF09		ld.w d15, [sp+]4
A0010754  81F0000B		mov d8, d0
A0010758  21A08F4B		dvinit d2/d3, d15, d8
A001075C  9000303B		mov d9, #3
A0010760  F6309001		mov.a a15, d9
A0010764  22F0806B		dvstep d2/d3, d2/d3, d8
A0010768  7FFEF0FD		loop a15, #-2
A001076C  22D0806B		dvadj d2/d3, d2/d3, d8
A0010770  F1F0200B		mov d15, d2

#10			ADD		yIni
(*) DINT
A0010774  F0006F0B		add d15, d15, d6

#11			ST		Line
(*) DINT
A0010778  21F0F00B		mov d2, d15

A001077C  0180000D		ret

END_FUNCTION
**************************************************
	List function: ScaleDW
**************************************************

FUNCTION ScaleDW : DINT

{ DE:"SCALE DW

Rev.0	1/2/2001 	by SSS

Scaling with rest recovery

ScaleDw=in/inDiv*inMol
The input is divided by inDiv and the result is multiplied by inMol.
In order to avoid the overflow, the function must be inMol*inDiv<2^31" }

	VAR_INPUT
	in : DINT; { DE:"input" } 
	inMol : DINT; { DE:"scale multiplier" } 
	inDiv : DINT; { DE:"scale divider" } 
	END_VAR

	*** Function data allocation

	Par in: REGISTER d4
	Par inMol: REGISTER d5
	Par inDiv: REGISTER d6

#0		{SRC:ScaleDW}
#1		
#2		
#3			LD		in
(*) UNDEF
A0010780  F1F0400B		mov d15, d4

#4			DIV		inDiv
(*) DINT
A0010784  81F0600B		mov d8, d6
A0010788  21A08F4B		dvinit d2/d3, d15, d8
A001078C  9000303B		mov d9, #3
A0010790  F6309001		mov.a a15, d9
A0010794  22F0806B		dvstep d2/d3, d2/d3, d8
A0010798  7FFEF0FD		loop a15, #-2
A001079C  22D0806B		dvadj d2/d3, d2/d3, d8
A00107A0  F1F0200B		mov d15, d2

#5			MUL		inMol
(*) DINT
A00107A4  F00A5F73		mul d15, d15, d5

#6			ADD(	in
(*) DINT
A00107A8  F53CAF89		st.w [-sp]4, d15 
A00107AC  F1F0400B		mov d15, d4

#7			MOD		inDiv
(*) DINT
A00107B0  81F0600B		mov d8, d6
A00107B4  21A08F4B		dvinit d2/d3, d15, d8
A00107B8  9000303B		mov d9, #3
A00107BC  F6309001		mov.a a15, d9
A00107C0  22F0806B		dvstep d2/d3, d2/d3, d8
A00107C4  7FFEF0FD		loop a15, #-2
A00107C8  22D0806B		dvadj d2/d3, d2/d3, d8
A00107CC  F1F0300B		mov d15, d3

#8			MUL		inMol
(*) DINT
A00107D0  F00A5F73		mul d15, d15, d5

#9			DIV		inDiv
(*) DINT
A00107D4  81F0600B		mov d8, d6
A00107D8  21A08F4B		dvinit d2/d3, d15, d8
A00107DC  9000303B		mov d9, #3
A00107E0  F6309001		mov.a a15, d9
A00107E4  22F0806B		dvstep d2/d3, d2/d3, d8
A00107E8  7FFEF0FD		loop a15, #-2
A00107EC  22D0806B		dvadj d2/d3, d2/d3, d8
A00107F0  F1F0200B		mov d15, d2

#10			)
(*) DINT
A00107F4  01F0F00B		mov d0, d15
A00107F8  0104AF09		ld.w d15, [sp+]4
A00107FC  F0000F0B		add d15, d15, d0

#11			ST		ScaleDW
(*) DINT
A0010800  21F0F00B		mov d2, d15

A0010804  0180000D		ret

END_FUNCTION
**************************************************
	List function: RBitIn
**************************************************

FUNCTION RBitIn : BOOL

{ DE:"8/10/2001		by SSS
Selector beetween a status 'inPar' and a bit in a word 'inWord'
If 'bitNumber' is from 0 to 15 the bit inWord[bitNumber] will be returned
else the inPar will be the output.

Inputs:
- inWord
- inPar
- bitNumber

Result:
- If 0<=bitNumber<=15	RESULT = RBit (inWord, bitNumber)
- If bitNumber >=16	RESULT = inPar" }

	VAR_INPUT
	inWord : UINT; { DE:"input word" } 
	inPar : BOOL; { DE:"input parameter" } 
	bitNumber : UINT; { DE:"number of bit to be read" } 
	END_VAR

	*** Function data allocation

	Par inWord: REGISTER d4
	Par inPar: REGISTER d5
	Par bitNumber: REGISTER d6

A0010808  A1F0400B		mov d10, d4
A001080C  B1F0500B		mov d11, d5
A0010810  C1F0600B		mov d12, d6

#0		{SRC:RBitIn}
#1		
#2			LD		bitNumber
(*) UNDEF
A0010814  F1F0C00B		mov d15, d12

#3			GE		16
(*) UINT
A0010818  8001003B		mov d8, #16
A001081C  F1508F0B		ge.u d15, d15, d8

#4			JMPC	l0_RBitIn
(-) BOOL
A0010820  80160FDF		jne d15, #0, #0x0016 ; JUMP 0xA001084C

#5		
#6			LD		inWord
(*) UNDEF
A0010824  F1F0A00B		mov d15, d10

#7			RBit	bitNumber
(-) UINT
A0010828  51F0C00B		mov d5, d12
A001082C  41F0F00B		mov d4, d15
A0010830  0094006D		call #0x000094 ; CALL 0xA0010958
A0010834  F1F0200B		mov d15, d2

#8			ST		RBitIn
(*) BOOL
A0010838  21F0F00B		mov d2, d15

#9		
#10			RET
(-) BOOL
A001083C  FA001091		movh.a a15, #0xA001 ; 0xA0010854
A0010840  1094FFD9		lea a15,[a15]0x0854
A0010844  0000000D		nop
A0010848  00300F2D		ji a15

#11		
#12		l0_RBitIn:
#13		
#14			LD		inPar
(*) UNDEF
A001084C  F1F0B00B		mov d15, d11

#15			ST		RBitIn
(*) BOOL
A0010850  21F0F00B		mov d2, d15

A0010854  0180000D		ret

END_FUNCTION
**************************************************
	List function: Segment
**************************************************

FUNCTION Segment : DINT

{ DE:"2/1/2001			by SSS

Segment passing through two points.
The function return the y(x) value. The function is the linear inter(extra)polation 
of the line passing through two points.
If the input value is outside the xIni, xEnd range the output will be 
yIni or yEnd according to the exceeding side.


The points are [xIni,yIni], [xEnd,yEnd

Result:
yIni			if	inX < xIni
Line(xIni, yIni, xEnd, yEnd)	if	xIni <= inX <= xEnd
yEnd			if	inX > xEnd" }

	VAR_INPUT
	inX : DINT; { DE:"input X [cnts]" } 
	xIni : DINT; { DE:"initial X [cnts]" } 
	yIni : DINT; { DE:"initial Y [cnts]" } 
	xEnd : DINT; { DE:"final X [cnts]" } 
	yEnd : DINT; { DE:"final Y [cnts]" } 
	END_VAR

	*** Function data allocation

	Par inX: REGISTER d4
	Par xIni: REGISTER d5
	Par yIni: REGISTER d6
	Par xEnd: REGISTER d7
	Par yEnd: LOCAL STACK FRAME AT 0(sp)

A0010858  A1F0400B		mov d10, d4
A001085C  B1F0500B		mov d11, d5
A0010860  C1F0600B		mov d12, d6
A0010864  D1F0700B		mov d13, d7
A0010868  C000A001		mov.aa a12, sp

#0		{SRC:Segment}
#1		
#2			LD		inX
(*) UNDEF
A001086C  F1F0A00B		mov d15, d10

#3			LT		xIni
(*) DINT
A0010870  F120BF0B		lt d15, d15, d11

#4			JMPCN	l0_Segment
(-) BOOL
A0010874  00080FDF		jeq d15, #0, #0x0008 ; JUMP 0xA0010884

#5		
#6			(*	inX < xIni	*)
#7		
#8			LD		yIni
(*) UNDEF
A0010878  F1F0C00B		mov d15, d12

#9			ST		Segment
(*) DINT
A001087C  21F0F00B		mov d2, d15

#10		
#11			JMP		lEnd_Segment
(-) DINT
A0010880  002C001D		j #0x00002C ; JUMP 0xA00108D8

#12		
#13		l0_Segment:
#14		
#15			LD		inX
(*) UNDEF
A0010884  F1F0A00B		mov d15, d10

#16			GT		xEnd
(*) DINT
A0010888  F120FD0B		lt d15, d13, d15

#17			JMPC	l1_Segment
(-) BOOL
A001088C  80200FDF		jne d15, #0, #0x0020 ; JUMP 0xA00108CC

#18		
#19			(*	xIni <= inX <= xEnd	*)
#20		
#21			LD		inX
(*) UNDEF
A0010890  F1F0A00B		mov d15, d10

#22			Line	xIni, yIni, xEnd, yEnd
(-) DINT
A0010894  F000C001		mov.aa a15, a12
A0010898  0000F819		ld.w d8, [a15]
A001089C  F53CA889		st.w [-sp]4, d8 
A00108A0  71F0D00B		mov d7, d13
A00108A4  61F0C00B		mov d6, d12
A00108A8  51F0B00B		mov d5, d11
A00108AC  41F0F00B		mov d4, d15
A00108B0  FF34FF6D		call #0xFFFF34 ; CALL 0xA0010718
A00108B4  F1F0200B		mov d15, d2
A00108B8  800040BB		mov.u d8, #4
A00108BC  E6308001		mov.a a14, d8
A00108C0  A010EA01		add.a sp, sp, a14

#23			ST		Segment
(*) DINT
A00108C4  21F0F00B		mov d2, d15

#24		
#25			JMP		lEnd_Segment
(-) DINT
A00108C8  0008001D		j #0x000008 ; JUMP 0xA00108D8

#26		
#27		l1_Segment:
#28		
#29			(*	inX > xEnd	*)
#30		
#31			LD		yEnd
(*) UNDEF
A00108CC  F000C001		mov.aa a15, a12
A00108D0  0000FF19		ld.w d15, [a15]

#32			ST		Segment
(*) DINT
A00108D4  21F0F00B		mov d2, d15

A00108D8  0180000D		ret

END_FUNCTION
**************************************************
	List function: WBit
**************************************************

FUNCTION WBit : UINT

{ DE:"WRITE BIT

Rev.0	29/1/2001 	by SSS

Writing of a bit into a word.
The 'bitValue' will be written in position 'bitNumber' of 'inWord'

" }

	VAR_INPUT
	inWord : UINT; { DE:"word to be written" } 
	bitNumber : UINT; { DE:"bit number to be written" } 
	bitValue : BOOL; { DE:"value of the bit to be written" } 
	END_VAR

	VAR
	wApp : UINT; { DE:"temp" } 
	END_VAR

	*** Function data allocation

	Par inWord: REGISTER d4
	Par bitNumber: REGISTER d5
	Par bitValue: REGISTER d6
	Var wApp: LOCAL STACK FRAME AT 0(sp)

A00108DC  800040BB		mov.u d8, #4
A00108E0  E6308001		mov.a a14, d8
A00108E4  A020EA01		sub.a sp, sp, a14

#0		{SRC:WBit}
#1		
#2		
#3		
#4			(*	Azzeramento bit numero bitNumber di inWord	*)
#5		
#6			LD		1
(*) UNDEF
A00108E8  F000103B		mov d15, #1

#7			ST		wApp
(*) USINT
A00108EC  F000A001		mov.aa a15, sp
A00108F0  0880FF89		st.h [a15], d15

#8			SHL		bitNumber
(*) UINT
A00108F4  81F0500B		mov d8, d5
A00108F8  0002003B		mov d0, #32
A00108FC  0006087F		jge d8, d0, #0x0006
A0010900  F0008F0F		sh d15, d15, d8
A0010904  0004001D		j #0x000004
A0010908  F000003B		mov d15, #0

#9			NOT
(*) UINT
A001090C  F1600F8F		nor d15, d15, #0

#10			AND		inWord
(*) UINT
A0010910  F0804F0F		and d15, d15, d4

#11			ST		wApp
(*) UINT
A0010914  F000A001		mov.aa a15, sp
A0010918  0880FF89		st.h [a15], d15

#12		
#13			(*	Scrittura bit	*)
#14		
#15			LD		bitValue
(*) UNDEF
A001091C  F1F0600B		mov d15, d6

#16			TO_UINT
(*) BOOL
#17			SHL		bitNumber
(*) UINT
A0010920  81F0500B		mov d8, d5
A0010924  0002003B		mov d0, #32
A0010928  0006087F		jge d8, d0, #0x0006
A001092C  F0008F0F		sh d15, d15, d8
A0010930  0004001D		j #0x000004
A0010934  F000003B		mov d15, #0

#18			OR		wApp
(*) UINT
A0010938  F000A001		mov.aa a15, sp
A001093C  08C0F809		ld.hu d8, [a15]
A0010940  F0A08F0F		or d15, d15, d8

#19			ST		WBit
(*) UINT
A0010944  21F0F00B		mov d2, d15

A0010948  800040BB		mov.u d8, #4
A001094C  E6308001		mov.a a14, d8
A0010950  A010EA01		add.a sp, sp, a14

A0010954  0180000D		ret

END_FUNCTION
**************************************************
	List function: RBit
**************************************************

FUNCTION RBit : BOOL

{ DE:"READ BIT

Rev.0	29/1/2001 	by SSS

Reading of a bit in 'bitWord' position inside 'inWord'." }

	VAR_INPUT
	inWord : UINT; { DE:"Word to be read" } 
	bitNumber : UINT; { DE:"bit number to be read" } 
	END_VAR

	*** Function data allocation

	Par inWord: REGISTER d4
	Par bitNumber: REGISTER d5

#0		{SRC:RBit}
#1		
#2		
#3			(*	Azzeramento bit numero bitNumber di inWord	*)
#4		
#5			LD		inWord
(*) UNDEF
A0010958  F1F0400B		mov d15, d4

#6			SHR		bitNumber
(*) UINT
A001095C  81F0500B		mov d8, d5
A0010960  0002003B		mov d0, #32
A0010964  0008087F		jge d8, d0, #0x0008
A0010968  8100088B		rsub d8, d8, #0
A001096C  F0008F0F		sh d15, d15, d8
A0010970  0004001D		j #0x000004
A0010974  F000003B		mov d15, #0

#7			AND		1
(*) UINT
A0010978  8000103B		mov d8, #1
A001097C  F0808F0F		and d15, d15, d8

#8			TO_BOOL
(*) UINT
A0010980  F2200F8B		ne d15, d15, #0

#9			ST		RBit
(*) BOOL
A0010984  21F0F00B		mov d2, d15

A0010988  0180000D		ret

END_FUNCTION
**************************************************
	List function: GAIN_LIM
**************************************************

FUNCTION GAIN_LIM : INT

{ DE:"Limited Gain Block

OUT= IN * M(on 32 bits) / D

the output is limited to +/-32767" }

	VAR_INPUT
	IN : INT; 
	M : INT; 
	D : INT; 
	END_VAR

	VAR
	temp : DINT; 
	END_VAR

	*** Function data allocation

	Par IN: REGISTER d4
	Par M: REGISTER d5
	Par D: REGISTER d6
	Var temp: LOCAL STACK FRAME AT 0(sp)

A001098C  A1F0400B		mov d10, d4
A0010990  B1F0500B		mov d11, d5
A0010994  C1F0600B		mov d12, d6
A0010998  800040BB		mov.u d8, #4
A001099C  E6308001		mov.a a14, d8
A00109A0  A020EA01		sub.a sp, sp, a14

#0		{SRC:GAIN_LIM}
#1		
#2			(* temp := MUL32( IN , M ); *)
#3			LD		IN	{L:1}
(*) UNDEF
A00109A4  F1F0A00B		mov d15, d10

#4			MUL32		M	{L:1}
(-) INT
A00109A8  51F0B00B		mov d5, d11
A00109AC  41F0F00B		mov d4, d15
A00109B0  F8009091		movh.a a15, #0x8009 ; MUL32 AT 0x800922F0
A00109B4  B230FFD9		lea a15,[a15]0x22F0
A00109B8  0000000D		nop
A00109BC  00000F2D		calli a15
A00109C0  F1F0200B		mov d15, d2

#5			ST		temp	{L:1}
(*) DINT
A00109C4  F000A001		mov.aa a15, sp
A00109C8  0000FF59		st.w [a15], d15

#6		
#7			(* GAIN_LIM := DIV32_LIM(temp ,  D) ; *)
#8			LD		temp	{L:3}
(*) UNDEF
A00109CC  F000A001		mov.aa a15, sp
A00109D0  0000FF19		ld.w d15, [a15]

#9			DIV32_LIM		D	{L:3}
(-) DINT
A00109D4  51F0C00B		mov d5, d12
A00109D8  41F0F00B		mov d4, d15
A00109DC  F8009091		movh.a a15, #0x8009 ; DIV32_LIM AT 0x80092310
A00109E0  C210FFD9		lea a15,[a15]0x2310
A00109E4  0000000D		nop
A00109E8  00000F2D		calli a15
A00109EC  F1F0200B		mov d15, d2

#10			ST		GAIN_LIM	{L:3}
(*) INT
A00109F0  21F0F00B		mov d2, d15

A00109F4  800040BB		mov.u d8, #4
A00109F8  E6308001		mov.a a14, d8
A00109FC  A010EA01		add.a sp, sp, a14

A0010A00  0180000D		ret

END_FUNCTION
**************************************************
	List function: CLAMP
**************************************************

FUNCTION CLAMP : INT

{ DE:"CLAMP

Output equal input value limited to +/- Clamp Value" }

	VAR_INPUT
	input : INT; 
	clampval : INT; 
	END_VAR

	*** Function data allocation

	Par input: REGISTER d4
	Par clampval: REGISTER d5

#0		{SRC:CLAMP}
#1		
#2		
#3			(* IF input > clampval *)
#4			LD		input	{L:1}
(*) UNDEF
A0010A04  F1F0400B		mov d15, d4

#5			GT		clampval	{L:1}
(*) INT
A0010A08  F120F50B		lt d15, d5, d15

#6			JMPCN	$label0	{L:1}
(-) BOOL
A0010A0C  00080FDF		jeq d15, #0, #0x0008 ; JUMP 0xA0010A1C

#7		
#8			(* THEN *)
#9		
#10				(* CLAMP := clampval; *)
#11				LD		clampval	{L:2}
(*) UNDEF
A0010A10  F1F0500B		mov d15, d5

#12				ST		CLAMP	{L:2}
(*) INT
A0010A14  21F0F00B		mov d2, d15

#13				JMP		$label2
(-) INT
A0010A18  0022001D		j #0x000022 ; JUMP 0xA0010A5C

#14		$label0:
#15		
#16			(* ELSIF input < (-clampval *)
#17			LD		input	{L:3}
(*) UNDEF
A0010A1C  F1F0400B		mov d15, d4

#18			LT(		clampval	{L:3}
(*) INT
A0010A20  F53CAF89		st.w [-sp]4, d15 
A0010A24  F1F0500B		mov d15, d5

#19			MUL		-1	{L:3}
(*) INT
A0010A28  8FFFF03B		mov d8, #-1
A0010A2C  F00A8F73		mul d15, d15, d8

#20			)	{L:3}
(*) INT
A0010A30  01F0F00B		mov d0, d15
A0010A34  0104AF09		ld.w d15, [sp+]4
A0010A38  F1200F0B		lt d15, d15, d0

#21			JMPCN	$label1	{L:3}
(-) BOOL
A0010A3C  000C0FDF		jeq d15, #0, #0x000C ; JUMP 0xA0010A54

#22		
#23			(* THEN *)
#24		
#25				(* CLAMP := -clampval; *)
#26				LD		clampval	{L:4}
(*) UNDEF
A0010A40  F1F0500B		mov d15, d5

#27				MUL		-1	{L:4}
(*) INT
A0010A44  8FFFF03B		mov d8, #-1
A0010A48  F00A8F73		mul d15, d15, d8

#28				ST		CLAMP	{L:4}
(*) INT
A0010A4C  21F0F00B		mov d2, d15

#29				JMP		$label2
(-) INT
A0010A50  0006001D		j #0x000006 ; JUMP 0xA0010A5C

#30		$label1:
#31		
#32			(* ELSE *)
#33		
#34				(* CLAMP := input; *)
#35				LD		input	{L:6}
(*) UNDEF
A0010A54  F1F0400B		mov d15, d4

#36				ST		CLAMP	{L:6}
(*) INT
A0010A58  21F0F00B		mov d2, d15

A0010A5C  0180000D		ret

END_FUNCTION
**************************************************
	List function: Line_int
**************************************************

FUNCTION Line_int : INT

{ DE:"The function return the y(x) value. The function is the linear inter(extra)polation
of the line passing through two points.
The points are defined with the following coordinates:
(x0, y0), (x1, y1).

The returned value is:
Result = y0+(y1-y0)/(x1-x0)*(x-x0)

result is of type integer" }

	VAR_INPUT
	x : INT; 
	x0 : INT; 
	y0 : INT; 
	x1 : INT; 
	y1 : INT; 
	END_VAR

	VAR
	help_long : DINT; 
	help_int : INT; 
	END_VAR

	*** Function data allocation

	Par x: REGISTER d4
	Par x0: REGISTER d5
	Par y0: REGISTER d6
	Par x1: REGISTER d7
	Par y1: LOCAL STACK FRAME AT 0(sp)
	Var help_long: LOCAL STACK FRAME AT 0(sp)
	Var help_int: CALLER STACK FRAME AT 4(sp)

A0010A60  A1F0400B		mov d10, d4
A0010A64  B1F0500B		mov d11, d5
A0010A68  C1F0600B		mov d12, d6
A0010A6C  D1F0700B		mov d13, d7
A0010A70  C000A001		mov.aa a12, sp
A0010A74  800080BB		mov.u d8, #8
A0010A78  E6308001		mov.a a14, d8
A0010A7C  A020EA01		sub.a sp, sp, a14

#0		{SRC:Line_int}
#1		
#2			(* Line_int := (y1-y0); *)
#3			LD		y1	{L:2}
(*) UNDEF
A0010A80  F000C001		mov.aa a15, a12
A0010A84  0880FF09		ld.h d15, [a15]

#4			SUB		y0	{L:2}
(*) INT
A0010A88  F080CF0B		sub d15, d15, d12

#5			ST		Line_int	{L:2}
(*) INT
A0010A8C  21F0F00B		mov d2, d15

#6		
#7			(* help_int := (x - x0); *)
#8			LD		x	{L:4}
(*) UNDEF
A0010A90  F1F0A00B		mov d15, d10

#9			SUB		x0	{L:4}
(*) INT
A0010A94  F080BF0B		sub d15, d15, d11

#10			ST		help_int	{L:4}
(*) INT
A0010A98  800040BB		mov.u d8, #0x4
A0010A9C  F600A801		addsc.a a15, sp, d8, #0
A0010AA0  0880FF89		st.h [a15], d15

#11		
#12			(* help_long:=	MUL32( Line_int , help_int ); *)
#13			LD		Line_int	{L:6}
(*) UNDEF
A0010AA4  F1F0200B		mov d15, d2

#14			MUL32		help_int	{L:6}
(-) INT
A0010AA8  800040BB		mov.u d8, #0x4
A0010AAC  F600A801		addsc.a a15, sp, d8, #0
A0010AB0  0880F509		ld.h d5, [a15]
A0010AB4  41F0F00B		mov d4, d15
A0010AB8  F8009091		movh.a a15, #0x8009 ; MUL32 AT 0x800922F0
A0010ABC  B230FFD9		lea a15,[a15]0x22F0
A0010AC0  0000000D		nop
A0010AC4  00000F2D		calli a15
A0010AC8  F1F0200B		mov d15, d2

#15			ST		help_long	{L:6}
(*) DINT
A0010ACC  F000A001		mov.aa a15, sp
A0010AD0  0000FF59		st.w [a15], d15

#16		
#17			(* help_int := (x1-x0); *)
#18			LD		x1	{L:8}
(*) UNDEF
A0010AD4  F1F0D00B		mov d15, d13

#19			SUB		x0	{L:8}
(*) INT
A0010AD8  F080BF0B		sub d15, d15, d11

#20			ST		help_int	{L:8}
(*) INT
A0010ADC  800040BB		mov.u d8, #0x4
A0010AE0  F600A801		addsc.a a15, sp, d8, #0
A0010AE4  0880FF89		st.h [a15], d15

#21		
#22			(* help_int := DIV32( help_long, help_int	); *)
#23			LD		help_long	{L:10}
(*) UNDEF
A0010AE8  F000A001		mov.aa a15, sp
A0010AEC  0000FF19		ld.w d15, [a15]

#24			DIV32		help_int	{L:10}
(-) DINT
A0010AF0  800040BB		mov.u d8, #0x4
A0010AF4  F600A801		addsc.a a15, sp, d8, #0
A0010AF8  0880F509		ld.h d5, [a15]
A0010AFC  41F0F00B		mov d4, d15
A0010B00  F8009091		movh.a a15, #0x8009 ; DIV32 AT 0x80092326
A0010B04  C226FFD9		lea a15,[a15]0x2326
A0010B08  0000000D		nop
A0010B0C  00000F2D		calli a15
A0010B10  F1F0200B		mov d15, d2

#25			ST		help_int	{L:10}
(*) INT
A0010B14  800040BB		mov.u d8, #0x4
A0010B18  F600A801		addsc.a a15, sp, d8, #0
A0010B1C  0880FF89		st.h [a15], d15

#26		
#27			(* Line_int := help_int + y0; *)
#28			LD		help_int	{L:12}
(*) UNDEF
A0010B20  800040BB		mov.u d8, #0x4
A0010B24  F600A801		addsc.a a15, sp, d8, #0
A0010B28  0880FF09		ld.h d15, [a15]

#29			ADD		y0	{L:12}
(*) INT
A0010B2C  F000CF0B		add d15, d15, d12

#30			ST		Line_int	{L:12}
(*) INT
A0010B30  21F0F00B		mov d2, d15

A0010B34  800080BB		mov.u d8, #8
A0010B38  E6308001		mov.a a14, d8
A0010B3C  A010EA01		add.a sp, sp, a14

A0010B40  0180000D		ret

END_FUNCTION
**************************************************
	List function: _ControlVersion
**************************************************

FUNCTION _ControlVersion : UDINT

{ DE:"LIBRERIA: Control

Rev.01.10.00	14/7/2003 	by SSS
Rev.01.20.00	27/05/2008 	Rnc

Regulation and control funcions and function blocks
Derivative;
Integral;
Low pass filter;
PID;
Delay;
Torque feed.fwd calculation
Diameter calculation;
Limits;
Ramp;
Up down.

Notes:
The library doesn't contain references to global variables, thus it is compatible with all the FW versions." }

	VAR_INPUT
	in : BOOL; 
	END_VAR

	*** Function data allocation

	Par in: REGISTER d4

#0		{SRC:_ControlVersion}
#1		
#2		
#3			LD		in
(*) UNDEF
A0010B44  F1F0400B		mov d15, d4

#4			JMPC	l0_Version
(-) BOOL
A0010B48  800E0FDF		jne d15, #0, #0x000E ; JUMP 0xA0010B64

#5		
#6			LD		0
(*) UNDEF
A0010B4C  F000003B		mov d15, #0

#7			ST		_ControlVersion
(*) USINT
A0010B50  21F0F00B		mov d2, d15

#8		
#9			RET
(-) USINT
A0010B54  FA001091		movh.a a15, #0xA001 ; 0xA0010B6C
A0010B58  D0ACFFD9		lea a15,[a15]0x0B6C
A0010B5C  0000000D		nop
A0010B60  00300F2D		ji a15

#10		
#11		l0_Version:
#12		
#13			(*	Indice di revisione.						*)
#14			(*	L'indice si legge nella seguente maniera:	*)
#15			(*	XXYYZZ => XX.YY.ZZ 							*)
#16			(*	XX = Revisione								*)
#17			(*	YY = Sotto revisione						*)
#18			(*	ZZ = Correzione								*)
#19		
#20			LD		012000
(*) UNDEF
A0010B64  F2EE003B		mov d15, #12000

#21			ST		_ControlVersion
(*) UINT
A0010B68  21F0F00B		mov d2, d15

A0010B6C  0180000D		ret

END_FUNCTION
**************************************************
	List function: LIMIT_R
**************************************************

FUNCTION LIMIT_R : REAL

{ DE:"LIMITI REAL

Version 1.0	3/8/2001		by SSS

Limits function with float vars

Notes:
	- If highLimit<lowLimit then highLimit=lowLimit


" }

	VAR_INPUT
	in : REAL; { DE:"Input var" } 
	lowLimit : REAL; { DE:"Ouput low limit" } 
	highLimit : REAL; { DE:"Output high limit" } 
	END_VAR

	*** Function data allocation

	Par in: REGISTER d4
	Par lowLimit: REGISTER d5
	Par highLimit: REGISTER d6

#0		{SRC:LIMIT_R}
#1			(*	check limits	*)
#2		
#3			LD		highLimit
(*) UNDEF
A0010B70  F1F0600B		mov d15, d6

#4			LT		lowLimit
(*) REAL
A0010B74  F0015F4B		cmp.f d15, d15, d5
A0010B78  F2001F8B		eq d15, d15, #1

#5			JMPCN	l0
(-) BOOL
A0010B7C  00060FDF		jeq d15, #0, #0x0006 ; JUMP 0xA0010B88

#6		
#7			(*	if highLimit<lowLimit then highLimit=lowLimit	*)
#8		
#9			LD		lowLimit
(*) UNDEF
A0010B80  F1F0500B		mov d15, d5

#10			ST		highLimit
(*) REAL
A0010B84  61F0F00B		mov d6, d15

#11		
#12		l0:
#13		
#14			(*	input >= low limit ?	*)
#15		
#16			LD		in
(*) UNDEF
A0010B88  F1F0400B		mov d15, d4

#17			GE		lowLimit
(*) REAL
A0010B8C  F0015F4B		cmp.f d15, d15, d5
A0010B90  F2201F8B		ne d15, d15, #1

#18			JMPC	l1
(-) BOOL
A0010B94  800E0FDF		jne d15, #0, #0x000E ; JUMP 0xA0010BB0

#19		
#20			(*	set output to low limit	*)
#21		
#22			LD		lowLimit
(*) UNDEF
A0010B98  F1F0500B		mov d15, d5

#23			ST		LIMIT_R
(*) REAL
A0010B9C  21F0F00B		mov d2, d15

#24		
#25			RET
(-) REAL
A0010BA0  FA001091		movh.a a15, #0xA001 ; 0xA0010BE4
A0010BA4  F0A4FFD9		lea a15,[a15]0x0BE4
A0010BA8  0000000D		nop
A0010BAC  00300F2D		ji a15

#26		
#27		l1:
#28		
#29			(*	input  <= high limit	*)
#30		
#31			LD		in
(*) UNDEF
A0010BB0  F1F0400B		mov d15, d4

#32			LE		highLimit
(*) REAL
A0010BB4  51F0600B		mov d5, d6
A0010BB8  F0015F4B		cmp.f d15, d15, d5
A0010BBC  F2204F8B		ne d15, d15, #4

#33			JMPC	l2
(-) BOOL
A0010BC0  800E0FDF		jne d15, #0, #0x000E ; JUMP 0xA0010BDC

#34		
#35			(*	set output to high limit	*)
#36		
#37			LD		highLimit
(*) UNDEF
A0010BC4  F1F0600B		mov d15, d6

#38			ST		LIMIT_R
(*) REAL
A0010BC8  21F0F00B		mov d2, d15

#39		
#40			RET
(-) REAL
A0010BCC  FA001091		movh.a a15, #0xA001 ; 0xA0010BE4
A0010BD0  F0A4FFD9		lea a15,[a15]0x0BE4
A0010BD4  0000000D		nop
A0010BD8  00300F2D		ji a15

#41		
#42		l2:
#43		
#44			(*     out = input		*)
#45		
#46			LD		in
(*) UNDEF
A0010BDC  F1F0400B		mov d15, d4

#47			ST		LIMIT_R
(*) REAL
A0010BE0  21F0F00B		mov d2, d15

A0010BE4  0180000D		ret

END_FUNCTION
**************************************************
	List function: _BasicVersion
**************************************************

FUNCTION _BasicVersion : UDINT

{ DE:"LIBRERIA: Basic

Rev.01.00.00	18/02/2002 	by Axel/SSS
Rev.01.01.00	27/05/2008 	Rnc

standard IEC 1131 functions and function blocks :
Timer;
Bistable;
Rising and falling edges detection;
Flip-flop.

Note:
no system or global variables are used, so that the library an be used regardless the FW version" }

	VAR_INPUT
	in : BOOL; 
	END_VAR

	*** Function data allocation

	Par in: REGISTER d4

#0		{SRC:_BasicVersion}
#1		
#2		
#3			LD		in
(*) UNDEF
A0010BE8  F1F0400B		mov d15, d4

#4			JMPC	l0_Version
(-) BOOL
A0010BEC  800E0FDF		jne d15, #0, #0x000E ; JUMP 0xA0010C08

#5		
#6			LD		0
(*) UNDEF
A0010BF0  F000003B		mov d15, #0

#7			ST		_BasicVersion
(*) USINT
A0010BF4  21F0F00B		mov d2, d15

#8		
#9			RET
(-) USINT
A0010BF8  FA001091		movh.a a15, #0xA001 ; 0xA0010C10
A0010BFC  00D0FFD9		lea a15,[a15]0x0C10
A0010C00  0000000D		nop
A0010C04  00300F2D		ji a15

#10		
#11		l0_Version:
#12		
#13			(*	Indice di revisione.						*)
#14			(*	L'indice si legge nella seguente maniera:	*)
#15			(*	XXYYZZ => XX.YY.ZZ 							*)
#16			(*	XX = Revisione								*)
#17			(*	YY = Sotto revisione						*)
#18			(*	ZZ = Correzione								*)
#19		
#20			LD		010100
(*) UNDEF
A0010C08  F277403B		mov d15, #10100

#21			ST		_BasicVersion
(*) UINT
A0010C0C  21F0F00B		mov d2, d15

A0010C10  0180000D		ret

END_FUNCTION
***********************************************************************
UNUSED FUNCTION BLOCKS:

	matrixProd
	matrixTranspose
	sysDBReadIntegerFieldMin
	sysDBReadIntegerFieldMax
	sysDBReadIntegerFieldEu
	sysDBReadIntegerFieldScale
	sysDBReadIntegerField
	sysDBReadRealFieldMin
	sysDBReadRealFieldMax
	sysDBReadRealFieldEu
	sysDBReadRealFieldScale
	sysDBReadRealField
	sysDBGetIntegerPar
	sysDBGetIntegerFieldMin
	sysDBGetIntegerFieldMax
	sysDBGetIntegerFieldEu
	sysDBGetIntegerFieldScale
	sysDBGetIntegerField
	sysDBGetRealPar
	sysDBGetRealFieldMin
	sysDBGetRealFieldMax
	sysDBGetRealFieldEu
	sysDBGetRealFieldScale
	sysDBGetRealField
	Counter
	Pulse
	SegmentFB
	ByteToBit
	WordToBit
	WordtoByte
	SquareWave
	TwoByteToWord
	TwoWordToDWord
	FourByteToDWord
	DiameterCalculation
	LP_FilterR
	PID
	PidR
	LinearRampR
	TorqueFFwd
	UpDown
	DelayDW
	UpDownR
	LinearRamp
	TON
	TOF
	SR
	RS
	R_TRIG
	FF_D
	F_TRIG

***********************************************************************
**************************************************
	List function block: InputConversionADV200
**************************************************

FUNCTION_BLOCK InputConversionADV200

	VAR_INPUT
	Krpm : REAL; { DE:"Costante di conversione [rpm/count]" } 
	Krad_s : REAL; { DE:"Costante di conversione [rad/s/count]" } 
	KArms : REAL; { DE:"Costante di conversione Corrente [Arms/count]" } 
	KCnt2Nm : REAL; { DE:"Conversione da count a Nm [cnt/Nm]" } 
	sysPos : DINT; { DE:"Posizione letta dall'azionamento " } 
	sysSpd : DINT; { DE:"VelocitÃ  letta dall'azionamento " } 
	sysIq : DINT; { DE:"Corrente letta dall'azionamento" } 
	sysTrqRef : DINT; { DE:"Coppia letta dall'azionamento" } 
	PosDINT : DINT; { DE:"Posizione letta dall'azionamento in funzione della velocitÃ " } 
	offset : REAL; { DE:"Offset di Posizione [rad]" } 
	sysRev : DINT; { DE:"Numero di rivoluzioni dell'encoder" } 
	END_VAR

	VAR_OUTPUT
	pos : REAL; { DE:"Posizione angolare del motore [rad]" } 
	vel_rpm : REAL; { DE:"VelocitÃ  del motore [rpm]" } 
	vel : REAL; { DE:"VelocitÃ  angolare del motore [rad/s]" } 
	trq : REAL; { DE:"Coppia erogata dal motore [N*m]" } 
	curr : REAL; { DE:"Corrente di coppia del motore [Arms]" } 
	END_VAR

	VAR_EXTERNAL
	v_Position : REAL; 
	v_Speed : REAL; 
	v_Torque : REAL; 
	END_VAR

A0010C14  C0004001		mov.aa a12, a4

#0		{SRC:InputConversionADV200}
#1		
#2			(* pos:=(TO_REAL(sysPos)/PosDINT+sysRev)*2.0*PI + offset; *)
#3			LD		sysPos	{L:4}
(*) UNDEF
A0010C18  800100BB		mov.u d8, #0x10
A0010C1C  F600C801		addsc.a a15, a12, d8, #0
A0010C20  0000FF19		ld.w d15, [a15]

#4			TO_REAL	{L:4}
(*) DINT
A0010C24  F1410F4B		itof d15, d15

#5			DIV		PosDINT	{L:4}
(*) REAL
A0010C28  800200BB		mov.u d8, #0x20
A0010C2C  F600C801		addsc.a a15, a12, d8, #0
A0010C30  0000F819		ld.w d8, [a15]
A0010C34  8141084B		itof d8, d8
A0010C38  F0518F4B		div.f d15, d15, d8

#6			ADD		sysRev	{L:4}
(*) REAL
A0010C3C  800280BB		mov.u d8, #0x28
A0010C40  F600C801		addsc.a a15, a12, d8, #0
A0010C44  0000F819		ld.w d8, [a15]
A0010C48  8141084B		itof d8, d8
A0010C4C  FF21086B		add.f d15, d15, d8

#7			MUL		2.0	{L:4}
(*) REAL
A0010C50  800000BB		mov.u d8, #0x0000 ; COSTREAL 2.000000
A0010C54  8400089B		addih d8, d8, #0x4000
A0010C58  F0418F4B		mul.f d15, d15, d8

#8			MUL		PI	{L:4}
(*) REAL
A0010C5C  80FDB0BB		mov.u d8, #0x0FDB ; COSTREAL 3.141593
A0010C60  8404989B		addih d8, d8, #0x4049
A0010C64  F0418F4B		mul.f d15, d15, d8

#9			ADD		offset	{L:4}
(*) REAL
A0010C68  800240BB		mov.u d8, #0x24
A0010C6C  F600C801		addsc.a a15, a12, d8, #0
A0010C70  0000F819		ld.w d8, [a15]
A0010C74  FF21086B		add.f d15, d15, d8

#10			ST		pos	{L:4}
(*) REAL
A0010C78  8002C0BB		mov.u d8, #0x2C
A0010C7C  F600C801		addsc.a a15, a12, d8, #0
A0010C80  0000FF59		st.w [a15], d15

#11		
#12			(* vel_rpm:= TO_REAL(sysSpd)*Krpm; *)
#13			LD		sysSpd	{L:6}
(*) UNDEF
A0010C84  800140BB		mov.u d8, #0x14
A0010C88  F600C801		addsc.a a15, a12, d8, #0
A0010C8C  0000FF19		ld.w d15, [a15]

#14			TO_REAL	{L:6}
(*) DINT
A0010C90  F1410F4B		itof d15, d15

#15			MUL		Krpm	{L:6}
(*) REAL
A0010C94  F000C001		mov.aa a15, a12
A0010C98  0000F819		ld.w d8, [a15]
A0010C9C  F0418F4B		mul.f d15, d15, d8

#16			ST		vel_rpm	{L:6}
(*) REAL
A0010CA0  800300BB		mov.u d8, #0x30
A0010CA4  F600C801		addsc.a a15, a12, d8, #0
A0010CA8  0000FF59		st.w [a15], d15

#17		
#18			(* vel:=TO_REAL(sysSpd)*Krad_s; *)
#19			LD		sysSpd	{L:8}
(*) UNDEF
A0010CAC  800140BB		mov.u d8, #0x14
A0010CB0  F600C801		addsc.a a15, a12, d8, #0
A0010CB4  0000FF19		ld.w d15, [a15]

#20			TO_REAL	{L:8}
(*) DINT
A0010CB8  F1410F4B		itof d15, d15

#21			MUL		Krad_s	{L:8}
(*) REAL
A0010CBC  800040BB		mov.u d8, #0x4
A0010CC0  F600C801		addsc.a a15, a12, d8, #0
A0010CC4  0000F819		ld.w d8, [a15]
A0010CC8  F0418F4B		mul.f d15, d15, d8

#22			ST		vel	{L:8}
(*) REAL
A0010CCC  800340BB		mov.u d8, #0x34
A0010CD0  F600C801		addsc.a a15, a12, d8, #0
A0010CD4  0000FF59		st.w [a15], d15

#23		
#24			(* curr:=TO_REAL(sysIq)*KArms; *)
#25			LD		sysIq	{L:10}
(*) UNDEF
A0010CD8  800180BB		mov.u d8, #0x18
A0010CDC  F600C801		addsc.a a15, a12, d8, #0
A0010CE0  0000FF19		ld.w d15, [a15]

#26			TO_REAL	{L:10}
(*) DINT
A0010CE4  F1410F4B		itof d15, d15

#27			MUL		KArms	{L:10}
(*) REAL
A0010CE8  800080BB		mov.u d8, #0x8
A0010CEC  F600C801		addsc.a a15, a12, d8, #0
A0010CF0  0000F819		ld.w d8, [a15]
A0010CF4  F0418F4B		mul.f d15, d15, d8

#28			ST		curr	{L:10}
(*) REAL
A0010CF8  8003C0BB		mov.u d8, #0x3C
A0010CFC  F600C801		addsc.a a15, a12, d8, #0
A0010D00  0000FF59		st.w [a15], d15

#29		
#30			(* trq := TO_REAL(sysTrqRef) * KCnt2Nm; *)
#31			LD		sysTrqRef	{L:12}
(*) UNDEF
A0010D04  8001C0BB		mov.u d8, #0x1C
A0010D08  F600C801		addsc.a a15, a12, d8, #0
A0010D0C  0000FF19		ld.w d15, [a15]

#32			TO_REAL	{L:12}
(*) DINT
A0010D10  F1410F4B		itof d15, d15

#33			MUL		KCnt2Nm	{L:12}
(*) REAL
A0010D14  8000C0BB		mov.u d8, #0xC
A0010D18  F600C801		addsc.a a15, a12, d8, #0
A0010D1C  0000F819		ld.w d8, [a15]
A0010D20  F0418F4B		mul.f d15, d15, d8

#34			ST		trq	{L:12}
(*) REAL
A0010D24  800380BB		mov.u d8, #0x38
A0010D28  F600C801		addsc.a a15, a12, d8, #0
A0010D2C  0000FF59		st.w [a15], d15

#35		
#36			(* v_Position := pos; *)
#37			LD		pos	{L:14}
(*) UNDEF
A0010D30  8002C0BB		mov.u d8, #0x2C
A0010D34  F600C801		addsc.a a15, a12, d8, #0
A0010D38  0000FF19		ld.w d15, [a15]

#38			ST		v_Position	{L:14}
(*) REAL
A0010D3C  022CCFA5		st.w #0x3202C, d15 ; ADR 0xC000202C
A0010D40  0000000D		nop

#39		
#40			(* v_Speed := vel; *)
#41			LD		vel	{L:16}
(*) UNDEF
A0010D44  800340BB		mov.u d8, #0x34
A0010D48  F600C801		addsc.a a15, a12, d8, #0
A0010D4C  0000FF19		ld.w d15, [a15]

#42			ST		v_Speed	{L:16}
(*) REAL
A0010D50  0230CFA5		st.w #0x32030, d15 ; ADR 0xC0002030
A0010D54  0000000D		nop

#43		
#44			(* v_Torque := trq; *)
#45			LD		trq	{L:18}
(*) UNDEF
A0010D58  800380BB		mov.u d8, #0x38
A0010D5C  F600C801		addsc.a a15, a12, d8, #0
A0010D60  0000FF19		ld.w d15, [a15]

#46			ST		v_Torque	{L:18}
(*) REAL
A0010D64  0234CFA5		st.w #0x32034, d15 ; ADR 0xC0002034
A0010D68  0000000D		nop

A0010D6C  0180000D		ret


Frame allocation:

	0000       : VAR Krpm
	0004       : VAR Krad_s
	0008       : VAR KArms
	000C       : VAR KCnt2Nm
	0010       : VAR sysPos
	0014       : VAR sysSpd
	0018       : VAR sysIq
	001C       : VAR sysTrqRef
	0020       : VAR PosDINT
	0024       : VAR offset
	0028       : VAR sysRev
	002C       : VAR pos
	0030       : VAR vel_rpm
	0034       : VAR vel
	0038       : VAR trq
	003C       : VAR curr

END_FUNCTION_BLOCK
**************************************************
	List function block: CircularBuffer
**************************************************

FUNCTION_BLOCK CircularBuffer

	VAR_INPUT
	input : REAL; 
	END_VAR

	VAR_OUTPUT
	sum : REAL; 
	overflow : BOOL; 
	END_VAR

	VAR
	buffer : ARRAY[ 0..9 ] OF REAL; 
	idx : INT; 
	END_VAR

A0010D70  C0004001		mov.aa a12, a4

#0		{SRC:CircularBuffer}
#1		
#2			(* sum:=sum-buffer[idx]; *)
#3			LD		sum	{L:1}
(*) UNDEF
A0010D74  800300BB		mov.u d8, #0x30
A0010D78  F600C801		addsc.a a15, a12, d8, #0
A0010D7C  0000FF19		ld.w d15, [a15]

#4			SUB		buffer[idx]	{L:1}
(*) REAL
A0010D80  800280BB		mov.u d8, #0x28
A0010D84  F600C801		addsc.a a15, a12, d8, #0
A0010D88  0880FE09		ld.h d14, [a15]
A0010D8C  800280BB		mov.u d8, #0x28
A0010D90  F600C801		addsc.a a15, a12, d8, #0
A0010D94  0880FE09		ld.h d14, [a15]
A0010D98  800000BB		mov.u d8, #0x0
A0010D9C  8000089B		addih d8, d8, #0x0
A0010DA0  F600C801		addsc.a a15, a12, d8, #0
A0010DA4  F602FE01		addsc.a a15, a15, d14, #2
A0010DA8  0000F819		ld.w d8, [a15]
A0010DAC  FF31086B		sub.f d15, d15, d8

#5			ST		sum	{L:1}
(*) REAL
A0010DB0  800300BB		mov.u d8, #0x30
A0010DB4  F600C801		addsc.a a15, a12, d8, #0
A0010DB8  0000FF59		st.w [a15], d15

#6		
#7			(* buffer[idx]:=input; *)
#8			LD		input	{L:2}
(*) UNDEF
A0010DBC  8002C0BB		mov.u d8, #0x2C
A0010DC0  F600C801		addsc.a a15, a12, d8, #0
A0010DC4  0000FF19		ld.w d15, [a15]

#9			ST		buffer[idx]	{L:2}
(*) REAL
A0010DC8  800280BB		mov.u d8, #0x28
A0010DCC  F600C801		addsc.a a15, a12, d8, #0
A0010DD0  0880FE09		ld.h d14, [a15]
A0010DD4  800000BB		mov.u d8, #0x0
A0010DD8  8000089B		addih d8, d8, #0x0
A0010DDC  F600C801		addsc.a a15, a12, d8, #0
A0010DE0  F602FE01		addsc.a a15, a15, d14, #2
A0010DE4  0000FF59		st.w [a15], d15

#10		
#11			(* sum:=sum+buffer[idx]; *)
#12			LD		sum	{L:3}
(*) UNDEF
A0010DE8  800300BB		mov.u d8, #0x30
A0010DEC  F600C801		addsc.a a15, a12, d8, #0
A0010DF0  0000FF19		ld.w d15, [a15]

#13			ADD		buffer[idx]	{L:3}
(*) REAL
A0010DF4  800280BB		mov.u d8, #0x28
A0010DF8  F600C801		addsc.a a15, a12, d8, #0
A0010DFC  0880FE09		ld.h d14, [a15]
A0010E00  800280BB		mov.u d8, #0x28
A0010E04  F600C801		addsc.a a15, a12, d8, #0
A0010E08  0880FE09		ld.h d14, [a15]
A0010E0C  800000BB		mov.u d8, #0x0
A0010E10  8000089B		addih d8, d8, #0x0
A0010E14  F600C801		addsc.a a15, a12, d8, #0
A0010E18  F602FE01		addsc.a a15, a15, d14, #2
A0010E1C  0000F819		ld.w d8, [a15]
A0010E20  FF21086B		add.f d15, d15, d8

#14			ST		sum	{L:3}
(*) REAL
A0010E24  800300BB		mov.u d8, #0x30
A0010E28  F600C801		addsc.a a15, a12, d8, #0
A0010E2C  0000FF59		st.w [a15], d15

#15		
#16		
#17			(* IF idx>=9 *)
#18			LD		idx	{L:4}
(*) UNDEF
A0010E30  800280BB		mov.u d8, #0x28
A0010E34  F600C801		addsc.a a15, a12, d8, #0
A0010E38  0880FF09		ld.h d15, [a15]

#19			GE		9	{L:4}
(*) INT
A0010E3C  8000903B		mov d8, #9
A0010E40  F1408F0B		ge d15, d15, d8

#20			JMPCN	$label0	{L:4}
(-) BOOL
A0010E44  00140FDF		jeq d15, #0, #0x0014 ; JUMP 0xA0010E6C

#21		
#22			(* THEN *)
#23		
#24				(* idx:=0; *)
#25				LD		0	{L:5}
(*) UNDEF
A0010E48  F000003B		mov d15, #0

#26				ST		idx	{L:5}
(*) USINT
A0010E4C  800280BB		mov.u d8, #0x28
A0010E50  F600C801		addsc.a a15, a12, d8, #0
A0010E54  0880FF89		st.h [a15], d15

#27		
#28				(* overflow:=TRUE; *)
#29				LD		TRUE	{L:6}
(*) UNDEF
A0010E58  F000103B		mov d15, #1

#30				ST		overflow	{L:6}
(*) BOOL
A0010E5C  800340BB		mov.u d8, #0x34
A0010E60  F600C801		addsc.a a15, a12, d8, #0
A0010E64  0000FF59		st.w [a15], d15

#31				JMP		$label1
(-) BOOL
A0010E68  0018001D		j #0x000018 ; JUMP 0xA0010E98

#32		$label0:
#33		
#34			(* ELSE *)
#35		
#36				(* idx:=idx+1; *)
#37				LD		idx	{L:8}
(*) UNDEF
A0010E6C  800280BB		mov.u d8, #0x28
A0010E70  F600C801		addsc.a a15, a12, d8, #0
A0010E74  0880FF09		ld.h d15, [a15]

#38				ADD		1	{L:8}
(*) INT
A0010E78  F0001F8B		add d15, d15, #1

#39				ST		idx	{L:8}
(*) INT
A0010E7C  800280BB		mov.u d8, #0x28
A0010E80  F600C801		addsc.a a15, a12, d8, #0
A0010E84  0880FF89		st.h [a15], d15

#40		
#41				(* overflow:=FALSE; *)
#42				LD		FALSE	{L:9}
(*) UNDEF
A0010E88  F000003B		mov d15, #0

#43				ST		overflow	{L:9}
(*) BOOL
A0010E8C  800340BB		mov.u d8, #0x34
A0010E90  F600C801		addsc.a a15, a12, d8, #0
A0010E94  0000FF59		st.w [a15], d15

A0010E98  0180000D		ret


Frame allocation:

	002C       : VAR input
	0030       : VAR sum
	0034 bit  0: VAR overflow
	0000       : VAR buffer
	0028       : VAR idx

END_FUNCTION_BLOCK
**************************************************
	List function block: RMS
**************************************************

FUNCTION_BLOCK RMS

	VAR_INPUT
	input : REAL; { DE:"actual value" } 
	END_VAR

	VAR_OUTPUT
	rms : REAL; { DE:"computed rms value" } 
	END_VAR

	VAR
	fast_buffer : CircularBuffer; 
	medium_buffer : CircularBuffer; 
	slow_buffer : CircularBuffer; 
	END_VAR

A0010E9C  C0004001		mov.aa a12, a4

#0		{SRC:RMS}
#1		
#2			(* fast_buffer.input:=input*input; *)
#3			LD		input	{L:1}
(*) UNDEF
A0010EA0  800A80BB		mov.u d8, #0xA8
A0010EA4  F600C801		addsc.a a15, a12, d8, #0
A0010EA8  0000FF19		ld.w d15, [a15]

#4			MUL		input	{L:1}
(*) REAL
A0010EAC  800A80BB		mov.u d8, #0xA8
A0010EB0  F600C801		addsc.a a15, a12, d8, #0
A0010EB4  0000F819		ld.w d8, [a15]
A0010EB8  F0418F4B		mul.f d15, d15, d8

#5			ST		fast_buffer.input	{L:1}
(*) REAL
A0010EBC  8002C0BB		mov.u d8, #0x2C
A0010EC0  F600C801		addsc.a a15, a12, d8, #0
A0010EC4  0000FF59		st.w [a15], d15

#6		
#7			(* fast_buffer() *)
#8			CAL		fast_buffer	{L:2}
(*) REAL
A0010EC8  F53CAF89		st.w [-sp]4, d15 
A0010ECC  4000C001		mov.aa a4, a12
A0010ED0  FA001091		movh.a a15, #0xA001 ; CALL TO FB AT 0xA0010D70
A0010ED4  50F0FFD9		lea a15,[a15]0x0D70
A0010ED8  0000000D		nop
A0010EDC  00000F2D		calli a15
A0010EE0  0104AF09		ld.w d15, [sp+]4

#9		
#10		
#11			(* IF fast_buffer.overflow *)
#12			LD		fast_buffer.overflow	{L:5}
(*) UNDEF
A0010EE4  800340BB		mov.u d8, #0x34
A0010EE8  F600C801		addsc.a a15, a12, d8, #0
A0010EEC  0000FF19		ld.w d15, [a15]

#13			JMPCN	$label0	{L:5}
(-) BOOL
A0010EF0  004A0FDF		jeq d15, #0, #0x004A ; JUMP 0xA0010F84

#14		
#15			(* THEN *)
#16		
#17				(* medium_buffer.input:=fast_buffer.sum; *)
#18				LD		fast_buffer.sum	{L:6}
(*) UNDEF
A0010EF4  800300BB		mov.u d8, #0x30
A0010EF8  F600C801		addsc.a a15, a12, d8, #0
A0010EFC  0000FF19		ld.w d15, [a15]

#19				ST		medium_buffer.input	{L:6}
(*) REAL
A0010F00  800640BB		mov.u d8, #0x64
A0010F04  F600C801		addsc.a a15, a12, d8, #0
A0010F08  0000FF59		st.w [a15], d15

#20		
#21				(* medium_buffer() *)
#22				CAL		medium_buffer	{L:7}
(*) REAL
A0010F0C  F53CAF89		st.w [-sp]4, d15 
A0010F10  4000C001		mov.aa a4, a12
A0010F14  800380BB		mov.u d8, #0x38 ; FB FRAME BASE 0x38
A0010F18  8000089B		addih d8, d8, #0x0
A0010F1C  46004801		addsc.a a4, a4, d8, #0
A0010F20  FA001091		movh.a a15, #0xA001 ; CALL TO FB AT 0xA0010D70
A0010F24  50F0FFD9		lea a15,[a15]0x0D70
A0010F28  0000000D		nop
A0010F2C  00000F2D		calli a15
A0010F30  0104AF09		ld.w d15, [sp+]4

#23		
#24		
#25				(* IF medium_buffer.overflow *)
#26				LD		medium_buffer.overflow	{L:8}
(*) UNDEF
A0010F34  8006C0BB		mov.u d8, #0x6C
A0010F38  F600C801		addsc.a a15, a12, d8, #0
A0010F3C  0000FF19		ld.w d15, [a15]

#27				JMPCN	$label1	{L:8}
(-) BOOL
A0010F40  00220FDF		jeq d15, #0, #0x0022 ; JUMP 0xA0010F84

#28		
#29				(* THEN *)
#30		
#31					(* slow_buffer.input:=medium_buffer.sum; *)
#32					LD		medium_buffer.sum	{L:9}
(*) UNDEF
A0010F44  800680BB		mov.u d8, #0x68
A0010F48  F600C801		addsc.a a15, a12, d8, #0
A0010F4C  0000FF19		ld.w d15, [a15]

#33					ST		slow_buffer.input	{L:9}
(*) REAL
A0010F50  8009C0BB		mov.u d8, #0x9C
A0010F54  F600C801		addsc.a a15, a12, d8, #0
A0010F58  0000FF59		st.w [a15], d15

#34		
#35					(* slow_buffer() *)
#36					CAL		slow_buffer	{L:10}
(*) REAL
A0010F5C  F53CAF89		st.w [-sp]4, d15 
A0010F60  4000C001		mov.aa a4, a12
A0010F64  800700BB		mov.u d8, #0x70 ; FB FRAME BASE 0x70
A0010F68  8000089B		addih d8, d8, #0x0
A0010F6C  46004801		addsc.a a4, a4, d8, #0
A0010F70  FA001091		movh.a a15, #0xA001 ; CALL TO FB AT 0xA0010D70
A0010F74  50F0FFD9		lea a15,[a15]0x0D70
A0010F78  0000000D		nop
A0010F7C  00000F2D		calli a15
A0010F80  0104AF09		ld.w d15, [sp+]4

#37		
#38		$label1:
#39				(* END_IF *)
#40		
#41		$label0:
#42			(* END_IF *)
#43		
#44			(* rms:=SQRT(slow_buffer.sum*0.001); *)
#45			LD		slow_buffer.sum	{L:13}
(*) UNDEF
A0010F84  800A00BB		mov.u d8, #0xA0
A0010F88  F600C801		addsc.a a15, a12, d8, #0
A0010F8C  0000FF19		ld.w d15, [a15]

#46			MUL		0.001	{L:13}
(*) REAL
A0010F90  8126F0BB		mov.u d8, #0x126F ; COSTREAL 0.001000
A0010F94  83A8389B		addih d8, d8, #0x3A83
A0010F98  F0418F4B		mul.f d15, d15, d8

#47			SQRT	{L:13}
(*) REAL
A0010F9C  41F0F00B		mov d4, d15
A0010FA0  F8009091		movh.a a15, #0x8009 ; _do_sqrt AT 0x80090598
A0010FA4  6058FFD9		lea a15,[a15]0x0598
A0010FA8  0000000D		nop
A0010FAC  00000F2D		calli a15
A0010FB0  F1F0200B		mov d15, d2

#48			ST		rms	{L:13}
(*) REAL
A0010FB4  800AC0BB		mov.u d8, #0xAC
A0010FB8  F600C801		addsc.a a15, a12, d8, #0
A0010FBC  0000FF59		st.w [a15], d15

A0010FC0  0180000D		ret


Frame allocation:

	00A8       : VAR input
	00AC       : VAR rms
	0000       : FB  fast_buffer
	0038       : FB  medium_buffer
	0070       : FB  slow_buffer

END_FUNCTION_BLOCK
**************************************************
	List function block: Mean
**************************************************

FUNCTION_BLOCK Mean

	VAR_INPUT
	input : REAL; { DE:"actual value" } 
	END_VAR

	VAR_OUTPUT
	mean : REAL; { DE:"computed rms value" } 
	END_VAR

	VAR
	fast_buffer : CircularBuffer; 
	medium_buffer : CircularBuffer; 
	slow_buffer : CircularBuffer; 
	END_VAR

A0010FC4  C0004001		mov.aa a12, a4

#0		{SRC:Mean}
#1		
#2			(* fast_buffer.input:=input; *)
#3			LD		input	{L:1}
(*) UNDEF
A0010FC8  800A80BB		mov.u d8, #0xA8
A0010FCC  F600C801		addsc.a a15, a12, d8, #0
A0010FD0  0000FF19		ld.w d15, [a15]

#4			ST		fast_buffer.input	{L:1}
(*) REAL
A0010FD4  8002C0BB		mov.u d8, #0x2C
A0010FD8  F600C801		addsc.a a15, a12, d8, #0
A0010FDC  0000FF59		st.w [a15], d15

#5		
#6			(* fast_buffer() *)
#7			CAL		fast_buffer	{L:2}
(*) REAL
A0010FE0  F53CAF89		st.w [-sp]4, d15 
A0010FE4  4000C001		mov.aa a4, a12
A0010FE8  FA001091		movh.a a15, #0xA001 ; CALL TO FB AT 0xA0010D70
A0010FEC  50F0FFD9		lea a15,[a15]0x0D70
A0010FF0  0000000D		nop
A0010FF4  00000F2D		calli a15
A0010FF8  0104AF09		ld.w d15, [sp+]4

#8		
#9		
#10			(* IF fast_buffer.overflow *)
#11			LD		fast_buffer.overflow	{L:5}
(*) UNDEF
A0010FFC  800340BB		mov.u d8, #0x34
A0011000  F600C801		addsc.a a15, a12, d8, #0
A0011004  0000FF19		ld.w d15, [a15]

#12			JMPCN	$label0	{L:5}
(-) BOOL
A0011008  004A0FDF		jeq d15, #0, #0x004A ; JUMP 0xA001109C

#13		
#14			(* THEN *)
#15		
#16				(* medium_buffer.input:=fast_buffer.sum; *)
#17				LD		fast_buffer.sum	{L:6}
(*) UNDEF
A001100C  800300BB		mov.u d8, #0x30
A0011010  F600C801		addsc.a a15, a12, d8, #0
A0011014  0000FF19		ld.w d15, [a15]

#18				ST		medium_buffer.input	{L:6}
(*) REAL
A0011018  800640BB		mov.u d8, #0x64
A001101C  F600C801		addsc.a a15, a12, d8, #0
A0011020  0000FF59		st.w [a15], d15

#19		
#20				(* medium_buffer() *)
#21				CAL		medium_buffer	{L:7}
(*) REAL
A0011024  F53CAF89		st.w [-sp]4, d15 
A0011028  4000C001		mov.aa a4, a12
A001102C  800380BB		mov.u d8, #0x38 ; FB FRAME BASE 0x38
A0011030  8000089B		addih d8, d8, #0x0
A0011034  46004801		addsc.a a4, a4, d8, #0
A0011038  FA001091		movh.a a15, #0xA001 ; CALL TO FB AT 0xA0010D70
A001103C  50F0FFD9		lea a15,[a15]0x0D70
A0011040  0000000D		nop
A0011044  00000F2D		calli a15
A0011048  0104AF09		ld.w d15, [sp+]4

#22		
#23		
#24				(* IF medium_buffer.overflow *)
#25				LD		medium_buffer.overflow	{L:8}
(*) UNDEF
A001104C  8006C0BB		mov.u d8, #0x6C
A0011050  F600C801		addsc.a a15, a12, d8, #0
A0011054  0000FF19		ld.w d15, [a15]

#26				JMPCN	$label1	{L:8}
(-) BOOL
A0011058  00220FDF		jeq d15, #0, #0x0022 ; JUMP 0xA001109C

#27		
#28				(* THEN *)
#29		
#30					(* slow_buffer.input:=medium_buffer.sum; *)
#31					LD		medium_buffer.sum	{L:9}
(*) UNDEF
A001105C  800680BB		mov.u d8, #0x68
A0011060  F600C801		addsc.a a15, a12, d8, #0
A0011064  0000FF19		ld.w d15, [a15]

#32					ST		slow_buffer.input	{L:9}
(*) REAL
A0011068  8009C0BB		mov.u d8, #0x9C
A001106C  F600C801		addsc.a a15, a12, d8, #0
A0011070  0000FF59		st.w [a15], d15

#33		
#34					(* slow_buffer() *)
#35					CAL		slow_buffer	{L:10}
(*) REAL
A0011074  F53CAF89		st.w [-sp]4, d15 
A0011078  4000C001		mov.aa a4, a12
A001107C  800700BB		mov.u d8, #0x70 ; FB FRAME BASE 0x70
A0011080  8000089B		addih d8, d8, #0x0
A0011084  46004801		addsc.a a4, a4, d8, #0
A0011088  FA001091		movh.a a15, #0xA001 ; CALL TO FB AT 0xA0010D70
A001108C  50F0FFD9		lea a15,[a15]0x0D70
A0011090  0000000D		nop
A0011094  00000F2D		calli a15
A0011098  0104AF09		ld.w d15, [sp+]4

#36		
#37		$label1:
#38				(* END_IF *)
#39		
#40		$label0:
#41			(* END_IF *)
#42		
#43			(* mean:=slow_buffer.sum*0.001; *)
#44			LD		slow_buffer.sum	{L:13}
(*) UNDEF
A001109C  800A00BB		mov.u d8, #0xA0
A00110A0  F600C801		addsc.a a15, a12, d8, #0
A00110A4  0000FF19		ld.w d15, [a15]

#45			MUL		0.001	{L:13}
(*) REAL
A00110A8  8126F0BB		mov.u d8, #0x126F ; COSTREAL 0.001000
A00110AC  83A8389B		addih d8, d8, #0x3A83
A00110B0  F0418F4B		mul.f d15, d15, d8

#46			ST		mean	{L:13}
(*) REAL
A00110B4  800AC0BB		mov.u d8, #0xAC
A00110B8  F600C801		addsc.a a15, a12, d8, #0
A00110BC  0000FF59		st.w [a15], d15

A00110C0  0180000D		ret


Frame allocation:

	00A8       : VAR input
	00AC       : VAR mean
	0000       : FB  fast_buffer
	0038       : FB  medium_buffer
	0070       : FB  slow_buffer

END_FUNCTION_BLOCK
**************************************************
	List function block: LineFB
**************************************************

FUNCTION_BLOCK LineFB

{ DE:"4/10/2001			by SSS

Calculation of the line passing through two points with the following coordinates (xIni,yIni), (xEnd,yEnd)

Result=yIni+(yEnd-yIni)/(xEnd-xIni)*(x-xIni)" }

	VAR_INPUT
	inX : DINT; { DE:"Input X [cnts]" } 
	xIni : DINT; { DE:"Initial X [cnts]" } 
	yIni : DINT; { DE:"Initial Y [cnts]" } 
	xEnd : DINT; { DE:"Final X [cnts]" } 
	yEnd : DINT; { DE:"Final Y [cnts]" } 
	END_VAR

	VAR_OUTPUT
	outY : DINT; { DE:"Output Y [cnts]" } 
	END_VAR

A00110C4  C0004001		mov.aa a12, a4

#0		{SRC:LineFB}
#1		
#2			LD		inX
(*) UNDEF
A00110C8  F000C001		mov.aa a15, a12
A00110CC  0000FF19		ld.w d15, [a15]

#3			SUB		xIni
(*) DINT
A00110D0  800040BB		mov.u d8, #0x4
A00110D4  F600C801		addsc.a a15, a12, d8, #0
A00110D8  0000F819		ld.w d8, [a15]
A00110DC  F0808F0B		sub d15, d15, d8

#4			MUL(	yEnd
(*) DINT
A00110E0  F53CAF89		st.w [-sp]4, d15 
A00110E4  800100BB		mov.u d8, #0x10
A00110E8  F600C801		addsc.a a15, a12, d8, #0
A00110EC  0000FF19		ld.w d15, [a15]

#5			SUB		yIni
(*) DINT
A00110F0  800080BB		mov.u d8, #0x8
A00110F4  F600C801		addsc.a a15, a12, d8, #0
A00110F8  0000F819		ld.w d8, [a15]
A00110FC  F0808F0B		sub d15, d15, d8

#6			)
(*) DINT
A0011100  01F0F00B		mov d0, d15
A0011104  0104AF09		ld.w d15, [sp+]4
A0011108  F00A0F73		mul d15, d15, d0

#7			DIV(	xEnd
(*) DINT
A001110C  F53CAF89		st.w [-sp]4, d15 
A0011110  8000C0BB		mov.u d8, #0xC
A0011114  F600C801		addsc.a a15, a12, d8, #0
A0011118  0000FF19		ld.w d15, [a15]

#8			SUB		xIni
(*) DINT
A001111C  800040BB		mov.u d8, #0x4
A0011120  F600C801		addsc.a a15, a12, d8, #0
A0011124  0000F819		ld.w d8, [a15]
A0011128  F0808F0B		sub d15, d15, d8

#9			)
(*) DINT
A001112C  01F0F00B		mov d0, d15
A0011130  0104AF09		ld.w d15, [sp+]4
A0011134  81F0000B		mov d8, d0
A0011138  21A08F4B		dvinit d2/d3, d15, d8
A001113C  9000303B		mov d9, #3
A0011140  F6309001		mov.a a15, d9
A0011144  22F0806B		dvstep d2/d3, d2/d3, d8
A0011148  7FFEF0FD		loop a15, #-2
A001114C  22D0806B		dvadj d2/d3, d2/d3, d8
A0011150  F1F0200B		mov d15, d2

#10			ADD		yIni
(*) DINT
A0011154  800080BB		mov.u d8, #0x8
A0011158  F600C801		addsc.a a15, a12, d8, #0
A001115C  0000F819		ld.w d8, [a15]
A0011160  F0008F0B		add d15, d15, d8

#11			ST		outY
(*) DINT
A0011164  800140BB		mov.u d8, #0x14
A0011168  F600C801		addsc.a a15, a12, d8, #0
A001116C  0000FF59		st.w [a15], d15

A0011170  0180000D		ret


Frame allocation:

	0000       : VAR inX
	0004       : VAR xIni
	0008       : VAR yIni
	000C       : VAR xEnd
	0010       : VAR yEnd
	0014       : VAR outY

END_FUNCTION_BLOCK
**************************************************
	List function block: Derivative_PB
**************************************************

FUNCTION_BLOCK Derivative_PB

{ DE:"DERIVATIVE + LOW PASS FILTER	(s/(1+s*TauP))

Rev.0	10/12/99 	by SSS
Suggestion: If there is no cpu time issue use DerivativeR.

Derivativ + Low pass filter with TAUP constant.
The basic values do not have to cause an overflow (2^31) in case two of them 
are multiplied each other.

I valori base devono essere tali da non provocare overflow
quando moltiplicati tra loro

Values to be used:
Signals	10000		Limits	-20000 -> +20000
Times	1000		Limits  0 -> 25000

Note:
1000 ms  max. filter (suggested < 80 ms)
Output: max. 32.000.000 counts" }

	VAR_INPUT
	inU : DINT; { DE:"Input signal. Referred to signals base value" } 
	fS : DINT; { DE:"sampling freq =1/Ts [1/s]. 
                     i.e. cycle time =1msec -> fS:=1000 sampling freq = 1kz" } 
	tauP : DINT; { DE:"Time constant. Referred to times base value" } 
	TiN : DINT; { DE:"Times base value
                        i.e. to set TimeBase = 1 sec, tau = 10msec
                        set
                        TiN := 1000
                        tauP:= 10" } 
	END_VAR

	VAR_OUTPUT
	outY : DINT; { DE:"Output signal. Referred to signals base value" } 
	END_VAR

	VAR
	Yint : DINT; { DE:"Internal signal. Rferred to Kr * signals base value" } 
	prevInU : DINT; { DE:"Prec step input signal" } 
	Kr : DINT; { DE:"signals scale" } 
	KrN : DINT; { DE:"signals scale numerator" } 
	KrD : DINT; { DE:"signals scale denominator" } 
	END_VAR

A0011174  C0004001		mov.aa a12, a4

#0		{SRC:Derivative_PB}
#1		
#2		
#3		
#4			(*	Calcolo Kr = KrN/KrD					*)
#5			(*	= (TAUi+TiC)/TiN = (fS*tauP+TiN/fS*TiN)	*)
#6		
#7			LD		fS
(*) UNDEF
A0011178  800180BB		mov.u d8, #0x18
A001117C  F600C801		addsc.a a15, a12, d8, #0
A0011180  0000FF19		ld.w d15, [a15]

#8			MUL		tauP
(*) DINT
A0011184  8001C0BB		mov.u d8, #0x1C
A0011188  F600C801		addsc.a a15, a12, d8, #0
A001118C  0000F819		ld.w d8, [a15]
A0011190  F00A8F73		mul d15, d15, d8

#9			ADD		TiN
(*) DINT
A0011194  800200BB		mov.u d8, #0x20
A0011198  F600C801		addsc.a a15, a12, d8, #0
A001119C  0000F819		ld.w d8, [a15]
A00111A0  F0008F0B		add d15, d15, d8

#10			ST		KrN
(*) DINT
A00111A4  8000C0BB		mov.u d8, #0xC
A00111A8  F600C801		addsc.a a15, a12, d8, #0
A00111AC  0000FF59		st.w [a15], d15

#11		
#12			LD		fS
(*) UNDEF
A00111B0  800180BB		mov.u d8, #0x18
A00111B4  F600C801		addsc.a a15, a12, d8, #0
A00111B8  0000FF19		ld.w d15, [a15]

#13			MUL		TiN
(*) DINT
A00111BC  800200BB		mov.u d8, #0x20
A00111C0  F600C801		addsc.a a15, a12, d8, #0
A00111C4  0000F819		ld.w d8, [a15]
A00111C8  F00A8F73		mul d15, d15, d8

#14			ST		KrD
(*) DINT
A00111CC  800100BB		mov.u d8, #0x10
A00111D0  F600C801		addsc.a a15, a12, d8, #0
A00111D4  0000FF59		st.w [a15], d15

#15		
#16			(*	Corpo derivativo							*)
#17			(*	Yint[k]=tauP/TiN*outY[k-1]+inU[k]-inU[k-1]	*)
#18			(*  Il segnale è referred to Yint*Kr				*)
#19		
#20			LD		tauP
(*) UNDEF
A00111D8  8001C0BB		mov.u d8, #0x1C
A00111DC  F600C801		addsc.a a15, a12, d8, #0
A00111E0  0000FF19		ld.w d15, [a15]

#21			MUL		outY
(*) DINT
A00111E4  800240BB		mov.u d8, #0x24
A00111E8  F600C801		addsc.a a15, a12, d8, #0
A00111EC  0000F819		ld.w d8, [a15]
A00111F0  F00A8F73		mul d15, d15, d8

#22			DIV		TiN
(*) DINT
A00111F4  800200BB		mov.u d8, #0x20
A00111F8  F600C801		addsc.a a15, a12, d8, #0
A00111FC  0000F819		ld.w d8, [a15]
A0011200  21A08F4B		dvinit d2/d3, d15, d8
A0011204  9000303B		mov d9, #3
A0011208  F6309001		mov.a a15, d9
A001120C  22F0806B		dvstep d2/d3, d2/d3, d8
A0011210  7FFEF0FD		loop a15, #-2
A0011214  22D0806B		dvadj d2/d3, d2/d3, d8
A0011218  F1F0200B		mov d15, d2

#23			ADD		inU
(*) DINT
A001121C  800140BB		mov.u d8, #0x14
A0011220  F600C801		addsc.a a15, a12, d8, #0
A0011224  0000F819		ld.w d8, [a15]
A0011228  F0008F0B		add d15, d15, d8

#24			SUB		prevInU
(*) DINT
A001122C  800040BB		mov.u d8, #0x4
A0011230  F600C801		addsc.a a15, a12, d8, #0
A0011234  0000F819		ld.w d8, [a15]
A0011238  F0808F0B		sub d15, d15, d8

#25			ST		Yint
(*) DINT
A001123C  F000C001		mov.aa a15, a12
A0011240  0000FF59		st.w [a15], d15

#26		
#27			(*	Scalatura uscita			*)
#28			(*	outY=Yint/Kr				*)
#29		
#30			LD		KrN
(*) UNDEF
A0011244  8000C0BB		mov.u d8, #0xC
A0011248  F600C801		addsc.a a15, a12, d8, #0
A001124C  0000FF19		ld.w d15, [a15]

#31			GE		KrD
(*) DINT
A0011250  800100BB		mov.u d8, #0x10
A0011254  F600C801		addsc.a a15, a12, d8, #0
A0011258  0000F819		ld.w d8, [a15]
A001125C  F1408F0B		ge d15, d15, d8

#32			JMPCN	l1
(-) BOOL
A0011260  002A0FDF		jeq d15, #0, #0x002A ; JUMP 0xA00112B4

#33		
#34			LD		Yint
(*) UNDEF
A0011264  F000C001		mov.aa a15, a12
A0011268  0000FF19		ld.w d15, [a15]

#35			DIV		KrN
(*) DINT
A001126C  8000C0BB		mov.u d8, #0xC
A0011270  F600C801		addsc.a a15, a12, d8, #0
A0011274  0000F819		ld.w d8, [a15]
A0011278  21A08F4B		dvinit d2/d3, d15, d8
A001127C  9000303B		mov d9, #3
A0011280  F6309001		mov.a a15, d9
A0011284  22F0806B		dvstep d2/d3, d2/d3, d8
A0011288  7FFEF0FD		loop a15, #-2
A001128C  22D0806B		dvadj d2/d3, d2/d3, d8
A0011290  F1F0200B		mov d15, d2

#36			MUL		KrD
(*) DINT
A0011294  800100BB		mov.u d8, #0x10
A0011298  F600C801		addsc.a a15, a12, d8, #0
A001129C  0000F819		ld.w d8, [a15]
A00112A0  F00A8F73		mul d15, d15, d8

#37			ST		outY
(*) DINT
A00112A4  800240BB		mov.u d8, #0x24
A00112A8  F600C801		addsc.a a15, a12, d8, #0
A00112AC  0000FF59		st.w [a15], d15

#38			JMP		l2
(-) DINT
A00112B0  0034001D		j #0x000034 ; JUMP 0xA0011318

#39		
#40		l1:
#41		
#42			LD		KrD
(*) UNDEF
A00112B4  800100BB		mov.u d8, #0x10
A00112B8  F600C801		addsc.a a15, a12, d8, #0
A00112BC  0000FF19		ld.w d15, [a15]

#43			DIV		KrN
(*) DINT
A00112C0  8000C0BB		mov.u d8, #0xC
A00112C4  F600C801		addsc.a a15, a12, d8, #0
A00112C8  0000F819		ld.w d8, [a15]
A00112CC  21A08F4B		dvinit d2/d3, d15, d8
A00112D0  9000303B		mov d9, #3
A00112D4  F6309001		mov.a a15, d9
A00112D8  22F0806B		dvstep d2/d3, d2/d3, d8
A00112DC  7FFEF0FD		loop a15, #-2
A00112E0  22D0806B		dvadj d2/d3, d2/d3, d8
A00112E4  F1F0200B		mov d15, d2

#44			ST		Kr
(*) DINT
A00112E8  800080BB		mov.u d8, #0x8
A00112EC  F600C801		addsc.a a15, a12, d8, #0
A00112F0  0000FF59		st.w [a15], d15

#45			LD		Yint
(*) UNDEF
A00112F4  F000C001		mov.aa a15, a12
A00112F8  0000FF19		ld.w d15, [a15]

#46			MUL		Kr
(*) DINT
A00112FC  800080BB		mov.u d8, #0x8
A0011300  F600C801		addsc.a a15, a12, d8, #0
A0011304  0000F819		ld.w d8, [a15]
A0011308  F00A8F73		mul d15, d15, d8

#47			ST		outY
(*) DINT
A001130C  800240BB		mov.u d8, #0x24
A0011310  F600C801		addsc.a a15, a12, d8, #0
A0011314  0000FF59		st.w [a15], d15

#48		
#49		l2:
#50		
#51			LD		inU
(*) UNDEF
A0011318  800140BB		mov.u d8, #0x14
A001131C  F600C801		addsc.a a15, a12, d8, #0
A0011320  0000FF19		ld.w d15, [a15]

#52			ST		prevInU
(*) DINT
A0011324  800040BB		mov.u d8, #0x4
A0011328  F600C801		addsc.a a15, a12, d8, #0
A001132C  0000FF59		st.w [a15], d15

A0011330  0180000D		ret


Frame allocation:

	0014       : VAR inU
	0018       : VAR fS
	001C       : VAR tauP
	0020       : VAR TiN
	0024       : VAR outY
	0000       : VAR Yint
	0004       : VAR prevInU
	0008       : VAR Kr
	000C       : VAR KrN
	0010       : VAR KrD

END_FUNCTION_BLOCK
**************************************************
	List function block: DerivativeR
**************************************************

FUNCTION_BLOCK DerivativeR

{ DE:"DERIVATIVE REAL

Version 1.0	3/8/2001		by SSS

Derivative with low passing filter with floating point variables

Transfer function:
Continous time:	outY(s)/inU(s)=s/(1+tauP*s)
Discrete time:	outY(z)/inU(z)={[1-z(-1)]/Ts}/{1+[1-z(-1)]*tauP/Ts}
" }

	VAR_INPUT
	inU : REAL; { DE:"input signal" } 
	tauP : REAL; { DE:"filter time constant in sec" } 
	Ts : REAL; { DE:"Sampling time; i.e. in Fast Cycle Ts := 0.001" } 
	END_VAR

	VAR_OUTPUT
	outY : REAL; { DE:"Output signal" } 
	END_VAR

	VAR
	prevInU : REAL; { DE:"input at prec step" } 
	END_VAR

A0011334  C0004001		mov.aa a12, a4

#0		{SRC:DerivativeR}
#1			(*	Corpo derivativo												*)
#2			(*	outY[k]=1/(tauP+Ts)*outY[k-1]+tauP/(tauP+Ts)*(inU[k]-inU[k-1])	*)
#3		
#4			LD		outY
(*) UNDEF
A0011338  800100BB		mov.u d8, #0x10
A001133C  F600C801		addsc.a a15, a12, d8, #0
A0011340  0000FF19		ld.w d15, [a15]

#5			MUL		tauP
(*) REAL
A0011344  800080BB		mov.u d8, #0x8
A0011348  F600C801		addsc.a a15, a12, d8, #0
A001134C  0000F819		ld.w d8, [a15]
A0011350  F0418F4B		mul.f d15, d15, d8

#6			ADD		inU
(*) REAL
A0011354  800040BB		mov.u d8, #0x4
A0011358  F600C801		addsc.a a15, a12, d8, #0
A001135C  0000F819		ld.w d8, [a15]
A0011360  FF21086B		add.f d15, d15, d8

#7			SUB		prevInU
(*) REAL
A0011364  F000C001		mov.aa a15, a12
A0011368  0000F819		ld.w d8, [a15]
A001136C  FF31086B		sub.f d15, d15, d8

#8			DIV(	tauP
(*) REAL
A0011370  F53CAF89		st.w [-sp]4, d15 
A0011374  800080BB		mov.u d8, #0x8
A0011378  F600C801		addsc.a a15, a12, d8, #0
A001137C  0000FF19		ld.w d15, [a15]

#9			ADD		Ts
(*) REAL
A0011380  8000C0BB		mov.u d8, #0xC
A0011384  F600C801		addsc.a a15, a12, d8, #0
A0011388  0000F819		ld.w d8, [a15]
A001138C  FF21086B		add.f d15, d15, d8

#10			)
(*) REAL
A0011390  01F0F00B		mov d0, d15
A0011394  0104AF09		ld.w d15, [sp+]4
A0011398  81F0000B		mov d8, d0
A001139C  F0518F4B		div.f d15, d15, d8

#11			ST		outY
(*) REAL
A00113A0  800100BB		mov.u d8, #0x10
A00113A4  F600C801		addsc.a a15, a12, d8, #0
A00113A8  0000FF59		st.w [a15], d15

#12		
#13			(*	Aggiornamento prevInU	*)
#14		
#15			LD		inU
(*) UNDEF
A00113AC  800040BB		mov.u d8, #0x4
A00113B0  F600C801		addsc.a a15, a12, d8, #0
A00113B4  0000FF19		ld.w d15, [a15]

#16			ST		prevInU
(*) REAL
A00113B8  F000C001		mov.aa a15, a12
A00113BC  0000FF59		st.w [a15], d15

A00113C0  0180000D		ret


Frame allocation:

	0004       : VAR inU
	0008       : VAR tauP
	000C       : VAR Ts
	0010       : VAR outY
	0000       : VAR prevInU

END_FUNCTION_BLOCK
**************************************************
	List function block: IntegratorDW
**************************************************

FUNCTION_BLOCK IntegratorDW

{ DE:"INTEGRATOR DOUBLE WORD

Version 1.0	25/10/2001		by SSS

Integrator with anti-windup function with double word variables

Transfer functions
Continuous time:
outY(s)/inU(s)=1/s
Discrete time
OutY(z)/inU(z)=Ts/[1-z(-1)]

Particular functions:
- Preset of the starting value (presetValue) when presetBit=TRUE;
- Minimum and maximum limits with anti-windup function.

Basic values to  be used:
Signals	16384
Times	4000" }

	VAR_INPUT
	inU : DINT; { DE:"Input signal. Referred to signals base value" } 
	preset : DINT; { DE:"Preset value. Referred to signals base value" } 
	fS : DINT; { DE:"sampling frequency =1/Ts [1/s]." } 
	lowLimit : DINT; { DE:"Lower limit. Referred to signals base value" } 
	highLimit : DINT; { DE:"Upper limit. Referred to signals base value" } 
	presetBit : BOOL; { DE:"Preset bit" } 
	END_VAR

	VAR_OUTPUT
	outY : DINT; { DE:"Output signal. Referred to signals base value" } 
	END_VAR

	VAR
	Yint : DINT; { DE:"Integrated internal signal. Referred to fS * signals base value" } 
	prevYint : DINT; { DE:"preceeding value of integrated internal signal" } 
	intLowLim : DINT; { DE:"Min internal limt. referred to fS * signals base value" } 
	intHighLim : DINT; { DE:"Max internal limit. referred to fS * signals base value" } 
	END_VAR

A00113C4  C0004001		mov.aa a12, a4

#0		{SRC:IntegratorDW}
#1		
#2		
#3			(*	Calcolo limiti interni		*)
#4			(*	= extLimit*fS				*)
#5		
#6			LD		lowLimit
(*) UNDEF
A00113C8  8001C0BB		mov.u d8, #0x1C
A00113CC  F600C801		addsc.a a15, a12, d8, #0
A00113D0  0000FF19		ld.w d15, [a15]

#7			MUL		fS
(*) DINT
A00113D4  800180BB		mov.u d8, #0x18
A00113D8  F600C801		addsc.a a15, a12, d8, #0
A00113DC  0000F819		ld.w d8, [a15]
A00113E0  F00A8F73		mul d15, d15, d8

#8			ST		intLowLim
(*) DINT
A00113E4  800080BB		mov.u d8, #0x8
A00113E8  F600C801		addsc.a a15, a12, d8, #0
A00113EC  0000FF59		st.w [a15], d15

#9		
#10			LD		highLimit
(*) UNDEF
A00113F0  800200BB		mov.u d8, #0x20
A00113F4  F600C801		addsc.a a15, a12, d8, #0
A00113F8  0000FF19		ld.w d15, [a15]

#11			MUL		fS
(*) DINT
A00113FC  800180BB		mov.u d8, #0x18
A0011400  F600C801		addsc.a a15, a12, d8, #0
A0011404  0000F819		ld.w d8, [a15]
A0011408  F00A8F73		mul d15, d15, d8

#12			ST		intHighLim
(*) DINT
A001140C  8000C0BB		mov.u d8, #0xC
A0011410  F600C801		addsc.a a15, a12, d8, #0
A0011414  0000FF59		st.w [a15], d15

#13		
#14			(*	Settaggio Preset value	*)
#15		
#16			LD		presetBit
(*) UNDEF
A0011418  800240BB		mov.u d8, #0x24
A001141C  F600C801		addsc.a a15, a12, d8, #0
A0011420  0000FF19		ld.w d15, [a15]

#17			JMPCN	l1
(-) BOOL
A0011424  00160FDF		jeq d15, #0, #0x0016 ; JUMP 0xA0011450

#18			LD		preset
(*) UNDEF
A0011428  800140BB		mov.u d8, #0x14
A001142C  F600C801		addsc.a a15, a12, d8, #0
A0011430  0000FF19		ld.w d15, [a15]

#19			MUL		fS
(*) DINT
A0011434  800180BB		mov.u d8, #0x18
A0011438  F600C801		addsc.a a15, a12, d8, #0
A001143C  0000F819		ld.w d8, [a15]
A0011440  F00A8F73		mul d15, d15, d8

#20			ST		Yint
(*) DINT
A0011444  F000C001		mov.aa a15, a12
A0011448  0000FF59		st.w [a15], d15

#21		
#22			JMP             l2
(-) DINT
A001144C  002A001D		j #0x00002A ; JUMP 0xA00114A0

#23		
#24		l1:
#25		
#26			(*	Corpo integratore								*)
#27			(*	Yint[k]=Yint[k-1]+inU[k]						*)
#28			(*  Il segnale è referred to Yin*fS					*)
#29		
#30			LD		inU
(*) UNDEF
A0011450  800100BB		mov.u d8, #0x10
A0011454  F600C801		addsc.a a15, a12, d8, #0
A0011458  0000FF19		ld.w d15, [a15]

#31			ADD		Yint
(*) DINT
A001145C  F000C001		mov.aa a15, a12
A0011460  0000F819		ld.w d8, [a15]
A0011464  F0008F0B		add d15, d15, d8

#32			ST		Yint
(*) DINT
A0011468  F000C001		mov.aa a15, a12
A001146C  0000FF59		st.w [a15], d15

#33		
#34			(*	Verifica limiti												*)
#35			(*  Se fuori limite Yint viene posto uguale al limite stesso	*)
#36		
#37			LD		Yint
(*) UNDEF
A0011470  F000C001		mov.aa a15, a12
A0011474  0000FF19		ld.w d15, [a15]

#38			LIMIT	intLowLim, intHighLim
(*) DINT
A0011478  800080BB		mov.u d8, #0x8
A001147C  F600C801		addsc.a a15, a12, d8, #0
A0011480  0000F819		ld.w d8, [a15]
A0011484  F1A0F80B		max d15, d8, d15
A0011488  8000C0BB		mov.u d8, #0xC
A001148C  F600C801		addsc.a a15, a12, d8, #0
A0011490  0000F819		ld.w d8, [a15]
A0011494  F180F80B		min d15, d8, d15

#39			ST		Yint
(*) DINT
A0011498  F000C001		mov.aa a15, a12
A001149C  0000FF59		st.w [a15], d15

#40		
#41		l2:
#42		
#43			(*	Scalatura uscita			*)
#44			(*	outY=Yint*YiN*ts/(UiN*TiN)	*)
#45			(*	=Yint/fS -> i valori base per i segnali devono essere uguali	*)
#46		
#47			LD		Yint
(*) UNDEF
A00114A0  F000C001		mov.aa a15, a12
A00114A4  0000FF19		ld.w d15, [a15]

#48			DIV		fS
(*) DINT
A00114A8  800180BB		mov.u d8, #0x18
A00114AC  F600C801		addsc.a a15, a12, d8, #0
A00114B0  0000F819		ld.w d8, [a15]
A00114B4  21A08F4B		dvinit d2/d3, d15, d8
A00114B8  9000303B		mov d9, #3
A00114BC  F6309001		mov.a a15, d9
A00114C0  22F0806B		dvstep d2/d3, d2/d3, d8
A00114C4  7FFEF0FD		loop a15, #-2
A00114C8  22D0806B		dvadj d2/d3, d2/d3, d8
A00114CC  F1F0200B		mov d15, d2

#49			ST		outY
(*) DINT
A00114D0  800280BB		mov.u d8, #0x28
A00114D4  F600C801		addsc.a a15, a12, d8, #0
A00114D8  0000FF59		st.w [a15], d15

A00114DC  0180000D		ret


Frame allocation:

	0010       : VAR inU
	0014       : VAR preset
	0018       : VAR fS
	001C       : VAR lowLimit
	0020       : VAR highLimit
	0024 bit  0: VAR presetBit
	0028       : VAR outY
	0000       : VAR Yint
	0004       : VAR prevYint
	0008       : VAR intLowLim
	000C       : VAR intHighLim

END_FUNCTION_BLOCK
**************************************************
	List function block: IntegratorR
**************************************************

FUNCTION_BLOCK IntegratorR

{ DE:"INTEGRATOR REAL

Version 1.0	3/8/2001		by SSS

Integrator with anti-windup function with floating point variables

Transfer functions
Continuous time:outY(s)/inU(s)=1/s
Discrete timeOutY(z)/inU(z)=Ts/[1-z(-1)]

Particular functions:
- Preset of the starting value (presetValue) when presetBit=TRUE;
- Minimum and maximum limits with anti-windup function" }

	VAR_INPUT
	inU : REAL; { DE:"Input variable" } 
	Ts : REAL; { DE:"Sampling time [s]" } 
	presetValue : REAL; { DE:"Preset value" } 
	presetBit : BOOL; { DE:"Preset command" } 
	lowLimit : REAL; { DE:"Output Lower limit " } 
	highLimit : REAL; { DE:"Output Upper limit " } 
	END_VAR

	VAR_OUTPUT
	outY : REAL; { DE:"Output variable" } 
	END_VAR

A00114E0  C0004001		mov.aa a12, a4

#0		{SRC:IntegratorR}
#1		
#2			(*	Settaggio Preset value	*)
#3		
#4			LD		presetBit
(*) UNDEF
A00114E4  8000C0BB		mov.u d8, #0xC
A00114E8  F600C801		addsc.a a15, a12, d8, #0
A00114EC  0000FF19		ld.w d15, [a15]

#5			JMPCN	l1
(-) BOOL
A00114F0  000E0FDF		jeq d15, #0, #0x000E ; JUMP 0xA001150C

#6			LD		presetValue
(*) UNDEF
A00114F4  800080BB		mov.u d8, #0x8
A00114F8  F600C801		addsc.a a15, a12, d8, #0
A00114FC  0000FF19		ld.w d15, [a15]

#7			ST		outY
(*) REAL
A0011500  800180BB		mov.u d8, #0x18
A0011504  F600C801		addsc.a a15, a12, d8, #0
A0011508  0000FF59		st.w [a15], d15

#8		
#9		l1:
#10		
#11			(*	Corpo integratore					*)
#12			(*	outY[k]=outY[k-1]+inU[k]*Ts			*)
#13		
#14			LD		inU
(*) UNDEF
A001150C  F000C001		mov.aa a15, a12
A0011510  0000FF19		ld.w d15, [a15]

#15			MUL		Ts
(*) REAL
A0011514  800040BB		mov.u d8, #0x4
A0011518  F600C801		addsc.a a15, a12, d8, #0
A001151C  0000F819		ld.w d8, [a15]
A0011520  F0418F4B		mul.f d15, d15, d8

#16			ADD		outY
(*) REAL
A0011524  800180BB		mov.u d8, #0x18
A0011528  F600C801		addsc.a a15, a12, d8, #0
A001152C  0000F819		ld.w d8, [a15]
A0011530  FF21086B		add.f d15, d15, d8

#17			ST		outY
(*) REAL
A0011534  800180BB		mov.u d8, #0x18
A0011538  F600C801		addsc.a a15, a12, d8, #0
A001153C  0000FF59		st.w [a15], d15

#18		
#19			(*	Verifica limiti												*)
#20			(*  Se fuori limite outY viene posto uguale al limite stesso	*)
#21		
#22			LD		outY
(*) UNDEF
A0011540  800180BB		mov.u d8, #0x18
A0011544  F600C801		addsc.a a15, a12, d8, #0
A0011548  0000FF19		ld.w d15, [a15]

#23			LIMIT_R	lowLimit, highLimit
(-) REAL
A001154C  800140BB		mov.u d8, #0x14
A0011550  F600C801		addsc.a a15, a12, d8, #0
A0011554  0000F619		ld.w d6, [a15]
A0011558  800100BB		mov.u d8, #0x10
A001155C  F600C801		addsc.a a15, a12, d8, #0
A0011560  0000F519		ld.w d5, [a15]
A0011564  41F0F00B		mov d4, d15
A0011568  FB04FF6D		call #0xFFFB04 ; CALL 0xA0010B70
A001156C  F1F0200B		mov d15, d2

#24			ST		outY
(*) REAL
A0011570  800180BB		mov.u d8, #0x18
A0011574  F600C801		addsc.a a15, a12, d8, #0
A0011578  0000FF59		st.w [a15], d15

A001157C  0180000D		ret


Frame allocation:

	0000       : VAR inU
	0004       : VAR Ts
	0008       : VAR presetValue
	000C bit  0: VAR presetBit
	0010       : VAR lowLimit
	0014       : VAR highLimit
	0018       : VAR outY

END_FUNCTION_BLOCK
**************************************************
	List function block: LP_FilterDW
**************************************************

FUNCTION_BLOCK LP_FilterDW

{ DE:"LOW PASS FILTER DOUBLE WORD

Version 1.0	23/8/2001		by SSS

First order low passing filter with double integer variables (32 bits)

Transfer functions
Continuous time:outY(s)/inU(s)=1/(1+s*(tauP/TiN))
Discrete timeoutY(z)/inU(z)=1/{1+[1-z(-1)]*tauP*fS}
Particular functions:
-	Preset of the starting value (presetValue) when presetBit=TRUE.
Note:
The basic values do not have to cause an overflow (2^31) in case two of them are multiplied.
Values to be used:
Signals	16384
Times	1000-1024

" }

	VAR_INPUT
	inU : DINT; { DE:"Input signal. Referred to signals base value" } 
	fS : DINT; { DE:"sampling frequency =1/Ts [1/s]." } 
	tauP : DINT; { DE:"Time constant. Referred to times base value" } 
	TiN : DINT; { DE:"Times base value. Corresponds to 1s." } 
	presetValue : DINT; { DE:"Preset value. Referred to signals base value" } 
	presetBit : BOOL; { DE:"Preset command" } 
	END_VAR

	VAR_OUTPUT
	outY : DINT; { DE:"Output signal. Referred to signals base value" } 
	END_VAR

	VAR
	Yint : DINT; { DE:"Internal filered signal. referred to Kr * signals base value" } 
	prevYint : DINT; { DE:"Integrated internal signal. Valore precedente" } 
	Kr : DINT; { DE:"Signal scale" } 
	prevRest : DINT; { DE:"Reminder of prec step division" } 
	auxYint : DINT; { DE:"aux var for division" } 
	END_VAR

A0011580  C0004001		mov.aa a12, a4

#0		{SRC:LP_FilterDW}
#1		
#2			(*	Settaggio Preset value	*)
#3		
#4			LD		presetBit
(*) UNDEF
A0011584  800280BB		mov.u d8, #0x28
A0011588  F600C801		addsc.a a15, a12, d8, #0
A001158C  0000FF19		ld.w d15, [a15]

#5			JMPCN	l1
(-) BOOL
A0011590  00160FDF		jeq d15, #0, #0x0016 ; JUMP 0xA00115BC

#6		
#7			LD		presetValue
(*) UNDEF
A0011594  800240BB		mov.u d8, #0x24
A0011598  F600C801		addsc.a a15, a12, d8, #0
A001159C  0000FF19		ld.w d15, [a15]

#8			ST		outY
(*) DINT
A00115A0  8002C0BB		mov.u d8, #0x2C
A00115A4  F600C801		addsc.a a15, a12, d8, #0
A00115A8  0000FF59		st.w [a15], d15

#9			RET
(-) DINT
A00115AC  FA001091		movh.a a15, #0xA001 ; 0xA00116E8
A00115B0  B168FFD9		lea a15,[a15]0x16E8
A00115B4  0000000D		nop
A00115B8  00300F2D		ji a15

#10		
#11		l1:
#12		
#13			(*	Calcolo Kr							*)
#14			(*	= (tauP+ts)/ts = 1+(fS*tauP/TiN)	*)
#15		
#16			LD		fS
(*) UNDEF
A00115BC  800180BB		mov.u d8, #0x18
A00115C0  F600C801		addsc.a a15, a12, d8, #0
A00115C4  0000FF19		ld.w d15, [a15]

#17			MUL		tauP
(*) DINT
A00115C8  8001C0BB		mov.u d8, #0x1C
A00115CC  F600C801		addsc.a a15, a12, d8, #0
A00115D0  0000F819		ld.w d8, [a15]
A00115D4  F00A8F73		mul d15, d15, d8

#18			DIV		TiN
(*) DINT
A00115D8  800200BB		mov.u d8, #0x20
A00115DC  F600C801		addsc.a a15, a12, d8, #0
A00115E0  0000F819		ld.w d8, [a15]
A00115E4  21A08F4B		dvinit d2/d3, d15, d8
A00115E8  9000303B		mov d9, #3
A00115EC  F6309001		mov.a a15, d9
A00115F0  22F0806B		dvstep d2/d3, d2/d3, d8
A00115F4  7FFEF0FD		loop a15, #-2
A00115F8  22D0806B		dvadj d2/d3, d2/d3, d8
A00115FC  F1F0200B		mov d15, d2

#19			ADD		1
(*) DINT
A0011600  F0001F8B		add d15, d15, #1

#20			ST		Kr
(*) DINT
A0011604  800080BB		mov.u d8, #0x8
A0011608  F600C801		addsc.a a15, a12, d8, #0
A001160C  0000FF59		st.w [a15], d15

#21		
#22			(*	Corpo filtro								*)
#23			(*	Yint[k]=(Kr-1)*outY[k-1]+inU[k]				*)
#24			(*  Il segnale è referred to Yin*Kr				*)
#25		
#26			LD		Kr
(*) UNDEF
A0011610  800080BB		mov.u d8, #0x8
A0011614  F600C801		addsc.a a15, a12, d8, #0
A0011618  0000FF19		ld.w d15, [a15]

#27			SUB		1
(*) DINT
A001161C  8000103B		mov d8, #1
A0011620  F0808F0B		sub d15, d15, d8

#28			MUL		outY
(*) DINT
A0011624  8002C0BB		mov.u d8, #0x2C
A0011628  F600C801		addsc.a a15, a12, d8, #0
A001162C  0000F819		ld.w d8, [a15]
A0011630  F00A8F73		mul d15, d15, d8

#29			ADD		inU
(*) DINT
A0011634  800140BB		mov.u d8, #0x14
A0011638  F600C801		addsc.a a15, a12, d8, #0
A001163C  0000F819		ld.w d8, [a15]
A0011640  F0008F0B		add d15, d15, d8

#30			ST		Yint
(*) DINT
A0011644  F000C001		mov.aa a15, a12
A0011648  0000FF59		st.w [a15], d15

#31		
#32			(*	Scalatura uscita con recupero resti			*)
#33			(*	outY=(Yint+/Kr								*)
#34		
#35			LD		Yint
(*) UNDEF
A001164C  F000C001		mov.aa a15, a12
A0011650  0000FF19		ld.w d15, [a15]

#36			ADD		prevRest
(*) DINT
A0011654  8000C0BB		mov.u d8, #0xC
A0011658  F600C801		addsc.a a15, a12, d8, #0
A001165C  0000F819		ld.w d8, [a15]
A0011660  F0008F0B		add d15, d15, d8

#37			ST		auxYint
(*) DINT
A0011664  800100BB		mov.u d8, #0x10
A0011668  F600C801		addsc.a a15, a12, d8, #0
A001166C  0000FF59		st.w [a15], d15

#38			DIV		Kr
(*) DINT
A0011670  800080BB		mov.u d8, #0x8
A0011674  F600C801		addsc.a a15, a12, d8, #0
A0011678  0000F819		ld.w d8, [a15]
A001167C  21A08F4B		dvinit d2/d3, d15, d8
A0011680  9000303B		mov d9, #3
A0011684  F6309001		mov.a a15, d9
A0011688  22F0806B		dvstep d2/d3, d2/d3, d8
A001168C  7FFEF0FD		loop a15, #-2
A0011690  22D0806B		dvadj d2/d3, d2/d3, d8
A0011694  F1F0200B		mov d15, d2

#39			ST		outY
(*) DINT
A0011698  8002C0BB		mov.u d8, #0x2C
A001169C  F600C801		addsc.a a15, a12, d8, #0
A00116A0  0000FF59		st.w [a15], d15

#40		
#41			(*	Calcolo resto per ciclo successivo	*)
#42		
#43			LD		auxYint
(*) UNDEF
A00116A4  800100BB		mov.u d8, #0x10
A00116A8  F600C801		addsc.a a15, a12, d8, #0
A00116AC  0000FF19		ld.w d15, [a15]

#44			SUB(	Kr
(*) DINT
A00116B0  F53CAF89		st.w [-sp]4, d15 
A00116B4  800080BB		mov.u d8, #0x8
A00116B8  F600C801		addsc.a a15, a12, d8, #0
A00116BC  0000FF19		ld.w d15, [a15]

#45			MUL		outY
(*) DINT
A00116C0  8002C0BB		mov.u d8, #0x2C
A00116C4  F600C801		addsc.a a15, a12, d8, #0
A00116C8  0000F819		ld.w d8, [a15]
A00116CC  F00A8F73		mul d15, d15, d8

#46			)
(*) DINT
A00116D0  01F0F00B		mov d0, d15
A00116D4  0104AF09		ld.w d15, [sp+]4
A00116D8  F0800F0B		sub d15, d15, d0

#47			ST		prevRest
(*) DINT
A00116DC  8000C0BB		mov.u d8, #0xC
A00116E0  F600C801		addsc.a a15, a12, d8, #0
A00116E4  0000FF59		st.w [a15], d15

A00116E8  0180000D		ret


Frame allocation:

	0014       : VAR inU
	0018       : VAR fS
	001C       : VAR tauP
	0020       : VAR TiN
	0024       : VAR presetValue
	0028 bit  0: VAR presetBit
	002C       : VAR outY
	0000       : VAR Yint
	0004       : VAR prevYint
	0008       : VAR Kr
	000C       : VAR prevRest
	0010       : VAR auxYint

END_FUNCTION_BLOCK
**************************************************
	List program: cyclic_prg
**************************************************

PROGRAM cyclic_prg

	VAR
	speed_cmd : REAL; 
	torque_max : REAL := 3.0; 
	speed_max : REAL := 100.0; 
	torque_cmd : REAL; 
	END_VAR

#0		{SRC:cyclic_prg}
#1		
#2			(* InputConv.sysSpd := sysSpd; *)
#3			LD		sysSpd	{L:2}
(*) UNDEF
A00116F0  50C0CF85		ld.w d15, #0x30D40 ; ADR 0xC0000D40

#4			ST		InputConv.sysSpd	{L:2}
(*) DINT
A00116F4  3054CFA5		st.w #0x304D4, d15 ; ADR 0xC00004D4

#5		
#6			(* InputConv.sysPos := sysPos; *)
#7			LD		sysPos	{L:3}
(*) UNDEF
A00116F8  50C4CF85		ld.w d15, #0x30D44 ; ADR 0xC0000D44

#8			ST		InputConv.sysPos	{L:3}
(*) DINT
A00116FC  3050CFA5		st.w #0x304D0, d15 ; ADR 0xC00004D0

#9		
#10			(* InputConv.sysIq := sysIq; *)
#11			LD		sysIq	{L:4}
(*) UNDEF
A0011700  50C8CF85		ld.w d15, #0x30D48 ; ADR 0xC0000D48

#12			ST		InputConv.sysIq	{L:4}
(*) DINT
A0011704  3058CFA5		st.w #0x304D8, d15 ; ADR 0xC00004D8

#13		
#14			(* InputConv.sysTrqRef := sysTrqRef; *)
#15			LD		sysTrqRef	{L:5}
(*) UNDEF
A0011708  2368DF85		ld.w d15, #0x374A8 ; ADR 0xD00034A8

#16			ST		InputConv.sysTrqRef	{L:5}
(*) DINT
A001170C  305CCFA5		st.w #0x304DC, d15 ; ADR 0xC00004DC

#17		
#18			(* InputConv.sysRev := sysRev; *)
#19			LD		sysRev	{L:6}
(*) UNDEF
A0011710  50CCCF85		ld.w d15, #0x30D4C ; ADR 0xC0000D4C

#20			ST		InputConv.sysRev	{L:6}
(*) DINT
A0011714  3068CFA5		st.w #0x304E8, d15 ; ADR 0xC00004E8

#21		
#22			(* InputConv.PosDINT:=sysSpeedPosPulsesPerRev; *)
#23			LD		sysSpeedPosPulsesPerRev	{L:7}
(*) UNDEF
A0011718  22F0DF85		ld.w d15, #0x36CB0 ; ADR 0xD0002CB0

#24			ST		InputConv.PosDINT	{L:7}
(*) DINT
A001171C  3060CFA5		st.w #0x304E0, d15 ; ADR 0xC00004E0

#25		
#26			(* InputConv() *)
#27			CAL		InputConv	{L:8}
(*) DINT
A0011720  F53CAF89		st.w [-sp]4, d15 
A0011724  4C000091		movh.a a4, #0xC000 ; FB FRAME BASE 0xC00004C0
A0011728  304044D9		lea a4,[a4]0x04C0
A001172C  FA001091		movh.a a15, #0xA001 ; CALL TO FB AT 0xA0010C14
A0011730  00D4FFD9		lea a15,[a15]0x0C14
A0011734  0000000D		nop
A0011738  00000F2D		calli a15
A001173C  0104AF09		ld.w d15, [sp+]4

#28		
#29		
#30			(* IF ENABLE_CYCLIC_PRG *)
#31			LD		ENABLE_CYCLIC_PRG	{L:27}
(*) UNDEF
A0011740  50D0CF85		ld.w d15, #0x30D50 ; ADR 0xC0000D50

#32			NOT	{L:27}
(*) BOOL
A0011744  8000103B		mov d8, #1
A0011748  9000003B		mov d9, #0
A001174C  FF40892B		sel d15, d15, d9, d8

#33			JMPCN	$label0	{L:27}
(-) BOOL
A0011750  00160FDF		jeq d15, #0, #0x0016 ; JUMP 0xA001177C

#34		
#35			(* THEN *)
#36		
#37				(* speed_cmd := 0.0; *)
#38				LD		0.0	{L:29}
(*) UNDEF
A0011754  F00000BB		mov.u d15, #0x0000 ; COSTREAL 0.000000
A0011758  F0000F9B		addih d15, d15, #0x0000

#39				ST		speed_cmd	{L:29}
(*) REAL
A001175C  50D4CFA5		st.w #0x30D54, d15 ; ADR 0xC0000D54

#40		
#41				(* torque_cmd := 0.0; *)
#42				LD		0.0	{L:30}
(*) UNDEF
A0011760  F00000BB		mov.u d15, #0x0000 ; COSTREAL 0.000000
A0011764  F0000F9B		addih d15, d15, #0x0000

#43				ST		torque_cmd	{L:30}
(*) REAL
A0011768  50D8CFA5		st.w #0x30D58, d15 ; ADR 0xC0000D58

#44		
#45				(* torque_max:=4.0; *)
#46				LD		4.0	{L:31}
(*) UNDEF
A001176C  F00000BB		mov.u d15, #0x0000 ; COSTREAL 4.000000
A0011770  F4080F9B		addih d15, d15, #0x4080

#47				ST		torque_max	{L:31}
(*) REAL
A0011774  50DCCFA5		st.w #0x30D5C, d15 ; ADR 0xC0000D5C

#48				JMP		$label1
(-) REAL
A0011778  01A8001D		j #0x0001A8 ; JUMP 0xA0011AC8

#49		$label0:
#50		
#51			(* ELSE *)
#52		
#53		
#54				(* IF p_MotorTorqueRef>torque_max *)
#55				LD		p_MotorTorqueRef	{L:34}
(*) UNDEF
A001177C  C1B8CF85		ld.w d15, #0x31B38 ; ADR 0xC0001B38

#56				GT		torque_max	{L:34}
(*) REAL
A0011780  50DCC585		ld.w d5, #0x30D5C ; ADR 0xC0000D5C
A0011784  F0015F4B		cmp.f d15, d15, d5
A0011788  F2004F8B		eq d15, d15, #4

#57				JMPCN	$label2	{L:34}
(-) BOOL
A001178C  00080FDF		jeq d15, #0, #0x0008 ; JUMP 0xA001179C

#58		
#59				(* THEN *)
#60		
#61					(* torque_cmd:=torque_max; *)
#62					LD		torque_max	{L:35}
(*) UNDEF
A0011790  50DCCF85		ld.w d15, #0x30D5C ; ADR 0xC0000D5C

#63					ST		torque_cmd	{L:35}
(*) REAL
A0011794  50D8CFA5		st.w #0x30D58, d15 ; ADR 0xC0000D58

#64					JMP		$label4
(-) REAL
A0011798  0024001D		j #0x000024 ; JUMP 0xA00117E0

#65		$label2:
#66		
#67				(* ELSIF p_MotorTorqueRef<-torque_max *)
#68				LD		p_MotorTorqueRef	{L:36}
(*) UNDEF
A001179C  C1B8CF85		ld.w d15, #0x31B38 ; ADR 0xC0001B38

#69				LT(		torque_max	{L:36}
(*) REAL
A00117A0  F53CAF89		st.w [-sp]4, d15 
A00117A4  50DCCF85		ld.w d15, #0x30D5C ; ADR 0xC0000D5C

#70				MUL		-1	{L:36}
(*) REAL
A00117A8  8FFFF03B		mov d8, #-1
A00117AC  8141084B		itof d8, d8
A00117B0  F0418F4B		mul.f d15, d15, d8

#71				)	{L:36}
(*) REAL
A00117B4  01F0F00B		mov d0, d15
A00117B8  0104AF09		ld.w d15, [sp+]4
A00117BC  51F0000B		mov d5, d0
A00117C0  F0015F4B		cmp.f d15, d15, d5
A00117C4  F2001F8B		eq d15, d15, #1

#72				JMPCN	$label3	{L:36}
(-) BOOL
A00117C8  00080FDF		jeq d15, #0, #0x0008 ; JUMP 0xA00117D8

#73		
#74				(* THEN *)
#75		
#76					(* torque_cmd:=torque_max; *)
#77					LD		torque_max	{L:37}
(*) UNDEF
A00117CC  50DCCF85		ld.w d15, #0x30D5C ; ADR 0xC0000D5C

#78					ST		torque_cmd	{L:37}
(*) REAL
A00117D0  50D8CFA5		st.w #0x30D58, d15 ; ADR 0xC0000D58

#79					JMP		$label4
(-) REAL
A00117D4  0006001D		j #0x000006 ; JUMP 0xA00117E0

#80		$label3:
#81		
#82				(* ELSE *)
#83		
#84					(* torque_cmd:=p_MotorTorqueRef; *)
#85					LD		p_MotorTorqueRef	{L:39}
(*) UNDEF
A00117D8  C1B8CF85		ld.w d15, #0x31B38 ; ADR 0xC0001B38

#86					ST		torque_cmd	{L:39}
(*) REAL
A00117DC  50D8CFA5		st.w #0x30D58, d15 ; ADR 0xC0000D58

#87		
#88		$label4:
#89				(* END_IF *)
#90		
#91				(* speed_cmd := p_MotorSpeedTarget; *)
#92				LD		p_MotorSpeedTarget	{L:41}
(*) UNDEF
A00117E0  C1ACCF85		ld.w d15, #0x31B2C ; ADR 0xC0001B2C

#93				ST		speed_cmd	{L:41}
(*) REAL
A00117E4  50D4CFA5		st.w #0x30D54, d15 ; ADR 0xC0000D54

#94		
#95				(* v_temperature:=TO_REAL(sysHeatSinkTemp)*0.1; *)
#96				LD		sysHeatSinkTemp	{L:42}
(*) UNDEF
A00117E8  2390DF85		ld.w d15, #0x37890 ; ADR 0xD0003890

#97				TO_REAL	{L:42}
(*) DINT
A00117EC  F1410F4B		itof d15, d15

#98				MUL		0.1	{L:42}
(*) REAL
A00117F0  8CCCD0BB		mov.u d8, #0xCCCD ; COSTREAL 0.100000
A00117F4  83DCC89B		addih d8, d8, #0x3DCC
A00117F8  F0418F4B		mul.f d15, d15, d8

#99				ST		v_temperature	{L:42}
(*) REAL
A00117FC  1218CFA5		st.w #0x32058, d15 ; ADR 0xC0002058

#100		
#101				(* rms_Id.input:=TO_REAL(sysId)*Cnt2A; *)
#102				LD		sysId	{L:44}
(*) UNDEF
A0011800  50E0CF85		ld.w d15, #0x30D60 ; ADR 0xC0000D60

#103				TO_REAL	{L:44}
(*) DINT
A0011804  F1410F4B		itof d15, d15

#104				MUL		Cnt2A	{L:44}
(*) REAL
A0011808  50E4C885		ld.w d8, #0x30D64 ; ADR 0xC0000D64
A001180C  F0418F4B		mul.f d15, d15, d8

#105				ST		rms_Id.input	{L:44}
(*) REAL
A0011810  6068CFA5		st.w #0x305A8, d15 ; ADR 0xC00005A8

#106		
#107				(* rms_Id() *)
#108				CAL		rms_Id	{L:45}
(*) REAL
A0011814  F53CAF89		st.w [-sp]4, d15 
A0011818  4C000091		movh.a a4, #0xC000 ; FB FRAME BASE 0xC0000500
A001181C  404044D9		lea a4,[a4]0x0500
A0011820  FA001091		movh.a a15, #0xA001 ; CALL TO FB AT 0xA0010E9C
A0011824  A0DCFFD9		lea a15,[a15]0x0E9C
A0011828  0000000D		nop
A001182C  00000F2D		calli a15
A0011830  0104AF09		ld.w d15, [sp+]4

#109		
#110				(* v_rms_Id:=rms_Id.rms; *)
#111				LD		rms_Id.rms	{L:46}
(*) UNDEF
A0011834  606CCF85		ld.w d15, #0x305AC ; ADR 0xC00005AC

#112				ST		v_rms_Id	{L:46}
(*) REAL
A0011838  1204CFA5		st.w #0x32044, d15 ; ADR 0xC0002044

#113		
#114				(* rms_Iq.input:=TO_REAL(sysIq)*Cnt2A; *)
#115				LD		sysIq	{L:48}
(*) UNDEF
A001183C  50C8CF85		ld.w d15, #0x30D48 ; ADR 0xC0000D48

#116				TO_REAL	{L:48}
(*) DINT
A0011840  F1410F4B		itof d15, d15

#117				MUL		Cnt2A	{L:48}
(*) REAL
A0011844  50E4C885		ld.w d8, #0x30D64 ; ADR 0xC0000D64
A0011848  F0418F4B		mul.f d15, d15, d8

#118				ST		rms_Iq.input	{L:48}
(*) REAL
A001184C  9058CFA5		st.w #0x30658, d15 ; ADR 0xC0000658

#119		
#120				(* rms_Iq() *)
#121				CAL		rms_Iq	{L:49}
(*) REAL
A0011850  F53CAF89		st.w [-sp]4, d15 
A0011854  4C000091		movh.a a4, #0xC000 ; FB FRAME BASE 0xC00005B0
A0011858  607044D9		lea a4,[a4]0x05B0
A001185C  FA001091		movh.a a15, #0xA001 ; CALL TO FB AT 0xA0010E9C
A0011860  A0DCFFD9		lea a15,[a15]0x0E9C
A0011864  0000000D		nop
A0011868  00000F2D		calli a15
A001186C  0104AF09		ld.w d15, [sp+]4

#122		
#123				(* v_rms_Iq:=rms_Iq.rms; *)
#124				LD		rms_Iq.rms	{L:50}
(*) UNDEF
A0011870  905CCF85		ld.w d15, #0x3065C ; ADR 0xC000065C

#125				ST		v_rms_Iq	{L:50}
(*) REAL
A0011874  1200CFA5		st.w #0x32040, d15 ; ADR 0xC0002040

#126		
#127				(* rms_Iout.input:=TO_REAL(sysIout)*Cnt2A; *)
#128				LD		sysIout	{L:52}
(*) UNDEF
A0011878  50E8CF85		ld.w d15, #0x30D68 ; ADR 0xC0000D68

#129				TO_REAL	{L:52}
(*) DINT
A001187C  F1410F4B		itof d15, d15

#130				MUL		Cnt2A	{L:52}
(*) REAL
A0011880  50E4C885		ld.w d8, #0x30D64 ; ADR 0xC0000D64
A0011884  F0418F4B		mul.f d15, d15, d8

#131				ST		rms_Iout.input	{L:52}
(*) REAL
A0011888  C048CFA5		st.w #0x30708, d15 ; ADR 0xC0000708

#132		
#133				(* rms_Iout() *)
#134				CAL		rms_Iout	{L:53}
(*) REAL
A001188C  F53CAF89		st.w [-sp]4, d15 
A0011890  4C000091		movh.a a4, #0xC000 ; FB FRAME BASE 0xC0000660
A0011894  906044D9		lea a4,[a4]0x0660
A0011898  FA001091		movh.a a15, #0xA001 ; CALL TO FB AT 0xA0010E9C
A001189C  A0DCFFD9		lea a15,[a15]0x0E9C
A00118A0  0000000D		nop
A00118A4  00000F2D		calli a15
A00118A8  0104AF09		ld.w d15, [sp+]4

#135		
#136				(* v_rms_Iout:=rms_Iout.rms; *)
#137				LD		rms_Iout.rms	{L:54}
(*) UNDEF
A00118AC  C04CCF85		ld.w d15, #0x3070C ; ADR 0xC000070C

#138				ST		v_rms_Iout	{L:54}
(*) REAL
A00118B0  1208CFA5		st.w #0x32048, d15 ; ADR 0xC0002048

#139		
#140				(* rms_Vdc.input:=TO_REAL(sysVdcLink)*(0.00000651925802); *)
#141				LD		sysVdcLink	{L:56}
(*) UNDEF
A00118B4  50ECCF85		ld.w d15, #0x30D6C ; ADR 0xC0000D6C

#142				TO_REAL	{L:56}
(*) DINT
A00118B8  F1410F4B		itof d15, d15

#143				MUL		0.00000651925802	{L:56}
(*) REAL
A00118BC  8C0000BB		mov.u d8, #0xC000 ; COSTREAL 0.000007
A00118C0  836DA89B		addih d8, d8, #0x36DA
A00118C4  F0418F4B		mul.f d15, d15, d8

#144				ST		rms_Vdc.input	{L:56}
(*) REAL
A00118C8  E078CFA5		st.w #0x307B8, d15 ; ADR 0xC00007B8

#145		
#146				(* rms_Vdc() *)
#147				CAL		rms_Vdc	{L:57}
(*) REAL
A00118CC  F53CAF89		st.w [-sp]4, d15 
A00118D0  4C000091		movh.a a4, #0xC000 ; FB FRAME BASE 0xC0000710
A00118D4  C05044D9		lea a4,[a4]0x0710
A00118D8  FA001091		movh.a a15, #0xA001 ; CALL TO FB AT 0xA0010E9C
A00118DC  A0DCFFD9		lea a15,[a15]0x0E9C
A00118E0  0000000D		nop
A00118E4  00000F2D		calli a15
A00118E8  0104AF09		ld.w d15, [sp+]4

#148		
#149				(* v_rms_Vdc:=rms_Vdc.rms; *)
#150				LD		rms_Vdc.rms	{L:58}
(*) UNDEF
A00118EC  E07CCF85		ld.w d15, #0x307BC ; ADR 0xC00007BC

#151				ST		v_rms_Vdc	{L:58}
(*) REAL
A00118F0  120CCFA5		st.w #0x3204C, d15 ; ADR 0xC000204C

#152		
#153				(* rms_Vo.input:=TO_REAL(sysVo)*(0.00000074505806); *)
#154				LD		sysVo	{L:60}
(*) UNDEF
A00118F4  50F0CF85		ld.w d15, #0x30D70 ; ADR 0xC0000D70

#155				TO_REAL	{L:60}
(*) DINT
A00118F8  F1410F4B		itof d15, d15

#156				MUL		0.00000074505806	{L:60}
(*) REAL
A00118FC  800000BB		mov.u d8, #0x0000 ; COSTREAL 0.000001
A0011900  8354889B		addih d8, d8, #0x3548
A0011904  F0418F4B		mul.f d15, d15, d8

#157				ST		rms_Vo.input	{L:60}
(*) REAL
A0011908  10A8CFA5		st.w #0x30868, d15 ; ADR 0xC0000868

#158		
#159				(* rms_Vo() *)
#160				CAL		rms_Vo	{L:61}
(*) REAL
A001190C  F53CAF89		st.w [-sp]4, d15 
A0011910  4C000091		movh.a a4, #0xC000 ; FB FRAME BASE 0xC00007C0
A0011914  F04044D9		lea a4,[a4]0x07C0
A0011918  FA001091		movh.a a15, #0xA001 ; CALL TO FB AT 0xA0010E9C
A001191C  A0DCFFD9		lea a15,[a15]0x0E9C
A0011920  0000000D		nop
A0011924  00000F2D		calli a15
A0011928  0104AF09		ld.w d15, [sp+]4

#161		
#162				(* v_rms_Vo:=rms_Vo.rms; *)
#163				LD		rms_Vo.rms	{L:62}
(*) UNDEF
A001192C  10ACCF85		ld.w d15, #0x3086C ; ADR 0xC000086C

#164				ST		v_rms_Vo	{L:62}
(*) REAL
A0011930  1210CFA5		st.w #0x32050, d15 ; ADR 0xC0002050

#165		
#166				(* rms_Speed.input:=v_Speed; *)
#167				LD		v_Speed	{L:64}
(*) UNDEF
A0011934  0230CF85		ld.w d15, #0x32030 ; ADR 0xC0002030

#168				ST		rms_Speed.input	{L:64}
(*) REAL
A0011938  4098CFA5		st.w #0x30918, d15 ; ADR 0xC0000918

#169		
#170				(* rms_Speed() *)
#171				CAL		rms_Speed	{L:65}
(*) REAL
A001193C  F53CAF89		st.w [-sp]4, d15 
A0011940  4C000091		movh.a a4, #0xC000 ; FB FRAME BASE 0xC0000870
A0011944  10B044D9		lea a4,[a4]0x0870
A0011948  FA001091		movh.a a15, #0xA001 ; CALL TO FB AT 0xA0010E9C
A001194C  A0DCFFD9		lea a15,[a15]0x0E9C
A0011950  0000000D		nop
A0011954  00000F2D		calli a15
A0011958  0104AF09		ld.w d15, [sp+]4

#172		
#173				(* v_rms_Speed:=rms_Speed.rms; *)
#174				LD		rms_Speed.rms	{L:66}
(*) UNDEF
A001195C  409CCF85		ld.w d15, #0x3091C ; ADR 0xC000091C

#175				ST		v_rms_Speed	{L:66}
(*) REAL
A0011960  1214CFA5		st.w #0x32054, d15 ; ADR 0xC0002054

#176		
#177				(* mean_Id.input:=TO_REAL(sysId)*Cnt2A; *)
#178				LD		sysId	{L:68}
(*) UNDEF
A0011964  50E0CF85		ld.w d15, #0x30D60 ; ADR 0xC0000D60

#179				TO_REAL	{L:68}
(*) DINT
A0011968  F1410F4B		itof d15, d15

#180				MUL		Cnt2A	{L:68}
(*) REAL
A001196C  50E4C885		ld.w d8, #0x30D64 ; ADR 0xC0000D64
A0011970  F0418F4B		mul.f d15, d15, d8

#181				ST		mean_Id.input	{L:68}
(*) REAL
A0011974  40F8CFA5		st.w #0x30D38, d15 ; ADR 0xC0000D38

#182		
#183				(* mean_Id() *)
#184				CAL		mean_Id	{L:70}
(*) REAL
A0011978  F53CAF89		st.w [-sp]4, d15 
A001197C  4C000091		movh.a a4, #0xC000 ; FB FRAME BASE 0xC0000C90
A0011980  20D044D9		lea a4,[a4]0x0C90
A0011984  FA001091		movh.a a15, #0xA001 ; CALL TO FB AT 0xA0010FC4
A0011988  F0C4FFD9		lea a15,[a15]0x0FC4
A001198C  0000000D		nop
A0011990  00000F2D		calli a15
A0011994  0104AF09		ld.w d15, [sp+]4

#185		
#186				(* v_mean_Id:=mean_Id.mean; *)
#187				LD		mean_Id.mean	{L:71}
(*) UNDEF
A0011998  40FCCF85		ld.w d15, #0x30D3C ; ADR 0xC0000D3C

#188				ST		v_mean_Id	{L:71}
(*) REAL
A001199C  1220CFA5		st.w #0x32060, d15 ; ADR 0xC0002060

#189		
#190				(* mean_Iq.input:=TO_REAL(sysIq)*Cnt2A; *)
#191				LD		sysIq	{L:73}
(*) UNDEF
A00119A0  50C8CF85		ld.w d15, #0x30D48 ; ADR 0xC0000D48

#192				TO_REAL	{L:73}
(*) DINT
A00119A4  F1410F4B		itof d15, d15

#193				MUL		Cnt2A	{L:73}
(*) REAL
A00119A8  50E4C885		ld.w d8, #0x30D64 ; ADR 0xC0000D64
A00119AC  F0418F4B		mul.f d15, d15, d8

#194				ST		mean_Iq.input	{L:73}
(*) REAL
A00119B0  20C8CFA5		st.w #0x30C88, d15 ; ADR 0xC0000C88

#195		
#196				(* mean_Iq() *)
#197				CAL		mean_Iq	{L:74}
(*) REAL
A00119B4  F53CAF89		st.w [-sp]4, d15 
A00119B8  4C000091		movh.a a4, #0xC000 ; FB FRAME BASE 0xC0000BE0
A00119BC  F0A044D9		lea a4,[a4]0x0BE0
A00119C0  FA001091		movh.a a15, #0xA001 ; CALL TO FB AT 0xA0010FC4
A00119C4  F0C4FFD9		lea a15,[a15]0x0FC4
A00119C8  0000000D		nop
A00119CC  00000F2D		calli a15
A00119D0  0104AF09		ld.w d15, [sp+]4

#198		
#199				(* v_mean_Iq:=mean_Iq.mean; *)
#200				LD		mean_Iq.mean	{L:75}
(*) UNDEF
A00119D4  20CCCF85		ld.w d15, #0x30C8C ; ADR 0xC0000C8C

#201				ST		v_mean_Iq	{L:75}
(*) REAL
A00119D8  121CCFA5		st.w #0x3205C, d15 ; ADR 0xC000205C

#202		
#203				(* mean_Iout.input:=TO_REAL(sysIout)*Cnt2A; *)
#204				LD		sysIout	{L:77}
(*) UNDEF
A00119DC  50E8CF85		ld.w d15, #0x30D68 ; ADR 0xC0000D68

#205				TO_REAL	{L:77}
(*) DINT
A00119E0  F1410F4B		itof d15, d15

#206				MUL		Cnt2A	{L:77}
(*) REAL
A00119E4  50E4C885		ld.w d8, #0x30D64 ; ADR 0xC0000D64
A00119E8  F0418F4B		mul.f d15, d15, d8

#207				ST		mean_Iout.input	{L:77}
(*) REAL
A00119EC  F098CFA5		st.w #0x30BD8, d15 ; ADR 0xC0000BD8

#208		
#209				(* mean_Iout() *)
#210				CAL		mean_Iout	{L:78}
(*) REAL
A00119F0  F53CAF89		st.w [-sp]4, d15 
A00119F4  4C000091		movh.a a4, #0xC000 ; FB FRAME BASE 0xC0000B30
A00119F8  C0B044D9		lea a4,[a4]0x0B30
A00119FC  FA001091		movh.a a15, #0xA001 ; CALL TO FB AT 0xA0010FC4
A0011A00  F0C4FFD9		lea a15,[a15]0x0FC4
A0011A04  0000000D		nop
A0011A08  00000F2D		calli a15
A0011A0C  0104AF09		ld.w d15, [sp+]4

#211		
#212				(* v_mean_Iout:=mean_Iout.mean; *)
#213				LD		mean_Iout.mean	{L:79}
(*) UNDEF
A0011A10  F09CCF85		ld.w d15, #0x30BDC ; ADR 0xC0000BDC

#214				ST		v_mean_Iout	{L:79}
(*) REAL
A0011A14  1224CFA5		st.w #0x32064, d15 ; ADR 0xC0002064

#215		
#216				(* mean_Vdc.input:=TO_REAL(sysVdcLink)*(0.00000651925802); *)
#217				LD		sysVdcLink	{L:81}
(*) UNDEF
A0011A18  50ECCF85		ld.w d15, #0x30D6C ; ADR 0xC0000D6C

#218				TO_REAL	{L:81}
(*) DINT
A0011A1C  F1410F4B		itof d15, d15

#219				MUL		0.00000651925802	{L:81}
(*) REAL
A0011A20  8C0000BB		mov.u d8, #0xC000 ; COSTREAL 0.000007
A0011A24  836DA89B		addih d8, d8, #0x36DA
A0011A28  F0418F4B		mul.f d15, d15, d8

#220				ST		mean_Vdc.input	{L:81}
(*) REAL
A0011A2C  90B8CFA5		st.w #0x30A78, d15 ; ADR 0xC0000A78

#221		
#222				(* mean_Vdc() *)
#223				CAL		mean_Vdc	{L:82}
(*) REAL
A0011A30  F53CAF89		st.w [-sp]4, d15 
A0011A34  4C000091		movh.a a4, #0xC000 ; FB FRAME BASE 0xC00009D0
A0011A38  709044D9		lea a4,[a4]0x09D0
A0011A3C  FA001091		movh.a a15, #0xA001 ; CALL TO FB AT 0xA0010FC4
A0011A40  F0C4FFD9		lea a15,[a15]0x0FC4
A0011A44  0000000D		nop
A0011A48  00000F2D		calli a15
A0011A4C  0104AF09		ld.w d15, [sp+]4

#224		
#225				(* v_mean_Vdc:=mean_Vdc.mean; *)
#226				LD		mean_Vdc.mean	{L:83}
(*) UNDEF
A0011A50  90BCCF85		ld.w d15, #0x30A7C ; ADR 0xC0000A7C

#227				ST		v_mean_Vdc	{L:83}
(*) REAL
A0011A54  1228CFA5		st.w #0x32068, d15 ; ADR 0xC0002068

#228		
#229				(* mean_Vo.input:=TO_REAL(sysVo)*(0.00000074505806); *)
#230				LD		sysVo	{L:85}
(*) UNDEF
A0011A58  50F0CF85		ld.w d15, #0x30D70 ; ADR 0xC0000D70

#231				TO_REAL	{L:85}
(*) DINT
A0011A5C  F1410F4B		itof d15, d15

#232				MUL		0.00000074505806	{L:85}
(*) REAL
A0011A60  800000BB		mov.u d8, #0x0000 ; COSTREAL 0.000001
A0011A64  8354889B		addih d8, d8, #0x3548
A0011A68  F0418F4B		mul.f d15, d15, d8

#233				ST		mean_Vo.input	{L:85}
(*) REAL
A0011A6C  7088CFA5		st.w #0x309C8, d15 ; ADR 0xC00009C8

#234		
#235				(* mean_Vo() *)
#236				CAL		mean_Vo	{L:86}
(*) REAL
A0011A70  F53CAF89		st.w [-sp]4, d15 
A0011A74  4C000091		movh.a a4, #0xC000 ; FB FRAME BASE 0xC0000920
A0011A78  40A044D9		lea a4,[a4]0x0920
A0011A7C  FA001091		movh.a a15, #0xA001 ; CALL TO FB AT 0xA0010FC4
A0011A80  F0C4FFD9		lea a15,[a15]0x0FC4
A0011A84  0000000D		nop
A0011A88  00000F2D		calli a15
A0011A8C  0104AF09		ld.w d15, [sp+]4

#237		
#238				(* v_mean_Vo:=mean_Vo.mean; *)
#239				LD		mean_Vo.mean	{L:87}
(*) UNDEF
A0011A90  708CCF85		ld.w d15, #0x309CC ; ADR 0xC00009CC

#240				ST		v_mean_Vo	{L:87}
(*) REAL
A0011A94  122CCFA5		st.w #0x3206C, d15 ; ADR 0xC000206C

#241		
#242				(* mean_Speed.input:=v_Speed; *)
#243				LD		v_Speed	{L:89}
(*) UNDEF
A0011A98  0230CF85		ld.w d15, #0x32030 ; ADR 0xC0002030

#244				ST		mean_Speed.input	{L:89}
(*) REAL
A0011A9C  C0A8CFA5		st.w #0x30B28, d15 ; ADR 0xC0000B28

#245		
#246				(* mean_Speed() *)
#247				CAL		mean_Speed	{L:90}
(*) REAL
A0011AA0  F53CAF89		st.w [-sp]4, d15 
A0011AA4  4C000091		movh.a a4, #0xC000 ; FB FRAME BASE 0xC0000A80
A0011AA8  A08044D9		lea a4,[a4]0x0A80
A0011AAC  FA001091		movh.a a15, #0xA001 ; CALL TO FB AT 0xA0010FC4
A0011AB0  F0C4FFD9		lea a15,[a15]0x0FC4
A0011AB4  0000000D		nop
A0011AB8  00000F2D		calli a15
A0011ABC  0104AF09		ld.w d15, [sp+]4

#248		
#249				(* v_mean_Speed:=mean_Speed.mean; *)
#250				LD		mean_Speed.mean	{L:91}
(*) UNDEF
A0011AC0  C0ACCF85		ld.w d15, #0x30B2C ; ADR 0xC0000B2C

#251				ST		v_mean_Speed	{L:91}
(*) REAL
A0011AC4  1230CFA5		st.w #0x32070, d15 ; ADR 0xC0002070

#252		
#253		$label1:
#254			(* END_IF *)
#255		
#256			(* sysSpdRef1 := TO_DINT(speed_cmd*VelConv); *)
#257			LD		speed_cmd	{L:96}
(*) UNDEF
A0011AC8  50D4CF85		ld.w d15, #0x30D54 ; ADR 0xC0000D54

#258			MUL		VelConv	{L:96}
(*) REAL
A0011ACC  50F4C885		ld.w d8, #0x30D74 ; ADR 0xC0000D74
A0011AD0  F0418F4B		mul.f d15, d15, d8

#259			TO_DINT	{L:96}
(*) REAL
A0011AD4  F1010F4B		ftoi d15, d15

#260			ST		sysSpdRef1	{L:96}
(*) DINT
A0011AD8  33E0DFA5		st.w #0x37CE0, d15 ; ADR 0xD0003CE0

#261		
#262			(* sysTrqFFwd := TO_DINT((torque_cmd) * KNm2Cnt); *)
#263			LD		torque_cmd	{L:97}
(*) UNDEF
A0011ADC  50D8CF85		ld.w d15, #0x30D58 ; ADR 0xC0000D58

#264			MUL		KNm2Cnt	{L:97}
(*) REAL
A0011AE0  50F8C885		ld.w d8, #0x30D78 ; ADR 0xC0000D78
A0011AE4  F0418F4B		mul.f d15, d15, d8

#265			TO_DINT	{L:97}
(*) REAL
A0011AE8  F1010F4B		ftoi d15, d15

#266			ST		sysTrqFFwd	{L:97}
(*) DINT
A0011AEC  C2A8DFA5		st.w #0x36B28, d15 ; ADR 0xD0002B28

A0011AF0  0180000D		ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
A0011AF4  FD000091		movh.a a15, #0xD000
A0011AF8  D2B0FFD9		lea a15,[a15]0x2B70
A0011AFC  0000FF19		ld.w d15, [a15]
A0011B00  FC000091		movh.a a15, #0xC000
A0011B04  50C0FFD9		lea a15,[a15]0x0D40
A0011B08  0000FF59		st.w [a15], d15

A0011B0C  FD000091		movh.a a15, #0xD000
A0011B10  E280FFD9		lea a15,[a15]0x2B80
A0011B14  0000FF19		ld.w d15, [a15]
A0011B18  FC000091		movh.a a15, #0xC000
A0011B1C  50C4FFD9		lea a15,[a15]0x0D44
A0011B20  0000FF59		st.w [a15], d15

A0011B24  FD000091		movh.a a15, #0xD000
A0011B28  D2ACFFD9		lea a15,[a15]0x2B6C
A0011B2C  0000FF19		ld.w d15, [a15]
A0011B30  FC000091		movh.a a15, #0xC000
A0011B34  50C8FFD9		lea a15,[a15]0x0D48
A0011B38  0000FF59		st.w [a15], d15

A0011B3C  FD000091		movh.a a15, #0xD000
A0011B40  E284FFD9		lea a15,[a15]0x2B84
A0011B44  0000FF19		ld.w d15, [a15]
A0011B48  FC000091		movh.a a15, #0xC000
A0011B4C  50CCFFD9		lea a15,[a15]0x0D4C
A0011B50  0000FF59		st.w [a15], d15

A0011B54  FD000091		movh.a a15, #0xD000
A0011B58  D2A8FFD9		lea a15,[a15]0x2B68
A0011B5C  0000FF19		ld.w d15, [a15]
A0011B60  FC000091		movh.a a15, #0xC000
A0011B64  50E0FFD9		lea a15,[a15]0x0D60
A0011B68  0000FF59		st.w [a15], d15

A0011B6C  FD000091		movh.a a15, #0xD000
A0011B70  C2B8FFD9		lea a15,[a15]0x2B38
A0011B74  0000FF19		ld.w d15, [a15]
A0011B78  FC000091		movh.a a15, #0xC000
A0011B7C  50E8FFD9		lea a15,[a15]0x0D68
A0011B80  0000FF59		st.w [a15], d15

A0011B84  FD000091		movh.a a15, #0xD000
A0011B88  D2BCFFD9		lea a15,[a15]0x2B7C
A0011B8C  0000FF19		ld.w d15, [a15]
A0011B90  FC000091		movh.a a15, #0xC000
A0011B94  50ECFFD9		lea a15,[a15]0x0D6C
A0011B98  0000FF59		st.w [a15], d15

A0011B9C  FD000091		movh.a a15, #0xD000
A0011BA0  C2BCFFD9		lea a15,[a15]0x2B3C
A0011BA4  0000FF19		ld.w d15, [a15]
A0011BA8  FC000091		movh.a a15, #0xC000
A0011BAC  50F0FFD9		lea a15,[a15]0x0D70
A0011BB0  0000FF59		st.w [a15], d15

A0011BB4  0180000D		ret


*** OUTPUT:
A0011BB8  0180000D		ret



**************************************************
	Init code generation for task Fast
**************************************************

A0011BBC  F00000BB		mov.u d15, #0x0000 ; COSTREAL 3.000000
A0011BC0  F4040F9B		addih d15, d15, #0x4040
A0011BC4  50DCCFA5		st.w #0x30D5C, d15 ; ADR 0xC0000D5C

A0011BC8  0180000D		ret

**************************************************
	List program: state_machine
**************************************************

PROGRAM state_machine

	VAR
	INIT_END : BOOL; { DE:"Transition result" } 
	CYCLE_STOP : BOOL; { DE:"Transition result" } 
	readRealPar : sysDBReadRealPar; 
	readIntPar : sysDBReadIntegerPar; 
	idx : UINT; 
	r_idx : USINT; 
	c_idx : USINT; 
	END_VAR

#0		{SRC:state_machine}
#1			LD		state_machine$$Init_x
(*) UNDEF
A0011BE0  50FCCF85		ld.w d15, #0x30D7C ; ADR 0xC0000D7C

#2			JMPCN	end_state_machine$Init
(-) BOOL
A0011BE4  011C0FDF		jeq d15, #0, #0x011C ; JUMP 0xA0011E1C

#3		
#4		(* BODY OF Init *)
#5		{SRC:state_machine/Init_state}
#6		
#7			(* INIT_END := FALSE; *)
#8			LD		FALSE	{L:3}
(*) UNDEF
A0011BE8  F000003B		mov d15, #0

#9			ST		INIT_END	{L:3}
(*) BOOL
A0011BEC  60C0CFA5		st.w #0x30D80, d15 ; ADR 0xC0000D80

#10		
#11			(* CYCLE_STOP := TRUE; *)
#12			LD		TRUE	{L:4}
(*) UNDEF
A0011BF0  F000103B		mov d15, #1

#13			ST		CYCLE_STOP	{L:4}
(*) BOOL
A0011BF4  60C4CFA5		st.w #0x30D84, d15 ; ADR 0xC0000D84

#14		
#15			(* ENABLE_CYCLIC_PRG := FALSE; *)
#16			LD		FALSE	{L:5}
(*) UNDEF
A0011BF8  F000003B		mov d15, #0

#17			ST		ENABLE_CYCLIC_PRG	{L:5}
(*) BOOL
A0011BFC  50D0CFA5		st.w #0x30D50, d15 ; ADR 0xC0000D50

#18		
#19			(* sysControlMode := 1; *)
#20			LD		1	{L:9}
(*) UNDEF
A0011C00  F000103B		mov d15, #1

#21			ST		sysControlMode	{L:9}
(*) USINT
A0011C04  FC000091		movh.a a15, #0xC000 ; ADR 0xC00045D0
A0011C08  7450FF59		st.w [a15]0x45D0, d15

#22		
#23			(* readRealPar.ipa := 300; *)
#24			LD		300	{L:13}
(*) UNDEF
A0011C0C  F012C03B		mov d15, #300

#25			ST		readRealPar.ipa	{L:13}
(*) UINT
A0011C10  60C8CFA5		st.w #0x30D88, d15 ; ADR 0xC0000D88

#26		
#27			(* readRealPar() *)
#28			CAL		readRealPar	{L:14}
(*) DINT
A0011C14  F53CAF89		st.w [-sp]4, d15 
A0011C18  4C000091		movh.a a4, #0xC000 ; ADR EMB-FUNCTION BLOCK AT 0xC0000D88
A0011C1C  60C844D9		lea a4,[a4]0x0D88
A0011C20  F8009091		movh.a a15, #0x8009 ; sysDBReadRealPar AT 0x80092698
A0011C24  A258FFD9		lea a15,[a15]0x2698
A0011C28  0000000D		nop
A0011C2C  00000F2D		calli a15
A0011C30  F1F0200B		mov d15, d2
A0011C34  0104AF09		ld.w d15, [sp+]4

#29		
#30			(* DriveRatCur:= readRealPar.val ; *)
#31			LD		readRealPar.val	{L:15}
(*) UNDEF
A0011C38  60D0CF85		ld.w d15, #0x30D90 ; ADR 0xC0000D90

#32			ST		DriveRatCur	{L:15}
(*) REAL
A0011C3C  60D4CFA5		st.w #0x30D94, d15 ; ADR 0xC0000D94

#33		
#34			(* InputConv.KArms:=DriveRatCur/(8192.0*65536.0); *)
#35			LD		DriveRatCur	{L:16}
(*) UNDEF
A0011C40  60D4CF85		ld.w d15, #0x30D94 ; ADR 0xC0000D94

#36			DIV(		8192.0	{L:16}
(*) REAL
A0011C44  F53CAF89		st.w [-sp]4, d15 
A0011C48  F00000BB		mov.u d15, #0x0000 ; COSTREAL 8192.000000
A0011C4C  F4600F9B		addih d15, d15, #0x4600

#37			MUL		65536.0	{L:16}
(*) REAL
A0011C50  800000BB		mov.u d8, #0x0000 ; COSTREAL 65536.000000
A0011C54  8478089B		addih d8, d8, #0x4780
A0011C58  F0418F4B		mul.f d15, d15, d8

#38			)	{L:16}
(*) REAL
A0011C5C  01F0F00B		mov d0, d15
A0011C60  0104AF09		ld.w d15, [sp+]4
A0011C64  81F0000B		mov d8, d0
A0011C68  F0518F4B		div.f d15, d15, d8

#39			ST		InputConv.KArms	{L:16}
(*) REAL
A0011C6C  3048CFA5		st.w #0x304C8, d15 ; ADR 0xC00004C8

#40		
#41			(* readIntPar.ipa := 680; *)
#42			LD		680	{L:20}
(*) UNDEF
A0011C70  F02A803B		mov d15, #680

#43			ST		readIntPar.ipa	{L:20}
(*) UINT
A0011C74  60D8CFA5		st.w #0x30D98, d15 ; ADR 0xC0000D98

#44		
#45			(* readIntPar() *)
#46			CAL		readIntPar	{L:21}
(*) DINT
A0011C78  F53CAF89		st.w [-sp]4, d15 
A0011C7C  4C000091		movh.a a4, #0xC000 ; ADR EMB-FUNCTION BLOCK AT 0xC0000D98
A0011C80  60D844D9		lea a4,[a4]0x0D98
A0011C84  F8009091		movh.a a15, #0x8009 ; sysDBReadIntegerPar AT 0x80092606
A0011C88  8246FFD9		lea a15,[a15]0x2606
A0011C8C  0000000D		nop
A0011C90  00000F2D		calli a15
A0011C94  F1F0200B		mov d15, d2
A0011C98  0104AF09		ld.w d15, [sp+]4

#47		
#48			(* FullScaleSpeed := TO_REAL(readIntPar.val) ; *)
#49			LD		readIntPar.val	{L:22}
(*) UNDEF
A0011C9C  60E0CF85		ld.w d15, #0x30DA0 ; ADR 0xC0000DA0

#50			TO_REAL	{L:22}
(*) DINT
A0011CA0  F1410F4B		itof d15, d15

#51			ST		FullScaleSpeed	{L:22}
(*) REAL
A0011CA4  60E4CFA5		st.w #0x30DA4, d15 ; ADR 0xC0000DA4

#52		
#53			(* InputConv.Krpm:=FullScaleSpeed/(16384.0*65536.0); *)
#54			LD		FullScaleSpeed	{L:23}
(*) UNDEF
A0011CA8  60E4CF85		ld.w d15, #0x30DA4 ; ADR 0xC0000DA4

#55			DIV(		16384.0	{L:23}
(*) REAL
A0011CAC  F53CAF89		st.w [-sp]4, d15 
A0011CB0  F00000BB		mov.u d15, #0x0000 ; COSTREAL 16384.000000
A0011CB4  F4680F9B		addih d15, d15, #0x4680

#56			MUL		65536.0	{L:23}
(*) REAL
A0011CB8  800000BB		mov.u d8, #0x0000 ; COSTREAL 65536.000000
A0011CBC  8478089B		addih d8, d8, #0x4780
A0011CC0  F0418F4B		mul.f d15, d15, d8

#57			)	{L:23}
(*) REAL
A0011CC4  01F0F00B		mov d0, d15
A0011CC8  0104AF09		ld.w d15, [sp+]4
A0011CCC  81F0000B		mov d8, d0
A0011CD0  F0518F4B		div.f d15, d15, d8

#58			ST		InputConv.Krpm	{L:23}
(*) REAL
A0011CD4  3040CFA5		st.w #0x304C0, d15 ; ADR 0xC00004C0

#59		
#60			(* InputConv.Krad_s:=InputConv.Krpm*2.0*PI/60.0; *)
#61			LD		InputConv.Krpm	{L:24}
(*) UNDEF
A0011CD8  3040CF85		ld.w d15, #0x304C0 ; ADR 0xC00004C0

#62			MUL		2.0	{L:24}
(*) REAL
A0011CDC  800000BB		mov.u d8, #0x0000 ; COSTREAL 2.000000
A0011CE0  8400089B		addih d8, d8, #0x4000
A0011CE4  F0418F4B		mul.f d15, d15, d8

#63			MUL		PI	{L:24}
(*) REAL
A0011CE8  80FDB0BB		mov.u d8, #0x0FDB ; COSTREAL 3.141593
A0011CEC  8404989B		addih d8, d8, #0x4049
A0011CF0  F0418F4B		mul.f d15, d15, d8

#64			DIV		60.0	{L:24}
(*) REAL
A0011CF4  800000BB		mov.u d8, #0x0000 ; COSTREAL 60.000000
A0011CF8  8427089B		addih d8, d8, #0x4270
A0011CFC  F0518F4B		div.f d15, d15, d8

#65			ST		InputConv.Krad_s	{L:24}
(*) REAL
A0011D00  3044CFA5		st.w #0x304C4, d15 ; ADR 0xC00004C4

#66		
#67			(* VelConv:=1.0/InputConv.Krad_s; *)
#68			LD		1.0	{L:25}
(*) UNDEF
A0011D04  F00000BB		mov.u d15, #0x0000 ; COSTREAL 1.000000
A0011D08  F3F80F9B		addih d15, d15, #0x3F80

#69			DIV		InputConv.Krad_s	{L:25}
(*) REAL
A0011D0C  3044C885		ld.w d8, #0x304C4 ; ADR 0xC00004C4
A0011D10  F0518F4B		div.f d15, d15, d8

#70			ST		VelConv	{L:25}
(*) REAL
A0011D14  50F4CFA5		st.w #0x30D74, d15 ; ADR 0xC0000D74

#71		
#72			(* Cnt2A:=InputConv.KArms; *)
#73			LD		InputConv.KArms	{L:26}
(*) UNDEF
A0011D18  3048CF85		ld.w d15, #0x304C8 ; ADR 0xC00004C8

#74			ST		Cnt2A	{L:26}
(*) REAL
A0011D1C  50E4CFA5		st.w #0x30D64, d15 ; ADR 0xC0000D64

#75		
#76			(* readRealPar.ipa := 2002; *)
#77			LD		2002	{L:29}
(*) UNDEF
A0011D20  F07D203B		mov d15, #2002

#78			ST		readRealPar.ipa	{L:29}
(*) UINT
A0011D24  60C8CFA5		st.w #0x30D88, d15 ; ADR 0xC0000D88

#79		
#80			(* readRealPar() *)
#81			CAL		readRealPar	{L:30}
(*) DINT
A0011D28  F53CAF89		st.w [-sp]4, d15 
A0011D2C  4C000091		movh.a a4, #0xC000 ; ADR EMB-FUNCTION BLOCK AT 0xC0000D88
A0011D30  60C844D9		lea a4,[a4]0x0D88
A0011D34  F8009091		movh.a a15, #0x8009 ; sysDBReadRealPar AT 0x80092698
A0011D38  A258FFD9		lea a15,[a15]0x2698
A0011D3C  0000000D		nop
A0011D40  00000F2D		calli a15
A0011D44  F1F0200B		mov d15, d2
A0011D48  0104AF09		ld.w d15, [sp+]4

#82		
#83			(* RatCur:= readRealPar.val ; *)
#84			LD		readRealPar.val	{L:31}
(*) UNDEF
A0011D4C  60D0CF85		ld.w d15, #0x30D90 ; ADR 0xC0000D90

#85			ST		RatCur	{L:31}
(*) REAL
A0011D50  60E8CFA5		st.w #0x30DA8, d15 ; ADR 0xC0000DA8

#86		
#87			(* readRealPar.ipa := 2010; *)
#88			LD		2010	{L:33}
(*) UNDEF
A0011D54  F07DA03B		mov d15, #2010

#89			ST		readRealPar.ipa	{L:33}
(*) UINT
A0011D58  60C8CFA5		st.w #0x30D88, d15 ; ADR 0xC0000D88

#90		
#91			(* readRealPar() *)
#92			CAL		readRealPar	{L:34}
(*) DINT
A0011D5C  F53CAF89		st.w [-sp]4, d15 
A0011D60  4C000091		movh.a a4, #0xC000 ; ADR EMB-FUNCTION BLOCK AT 0xC0000D88
A0011D64  60C844D9		lea a4,[a4]0x0D88
A0011D68  F8009091		movh.a a15, #0x8009 ; sysDBReadRealPar AT 0x80092698
A0011D6C  A258FFD9		lea a15,[a15]0x2698
A0011D70  0000000D		nop
A0011D74  00000F2D		calli a15
A0011D78  F1F0200B		mov d15, d2
A0011D7C  0104AF09		ld.w d15, [sp+]4

#93		
#94			(* RatKTrq:= readRealPar.val ; *)
#95			LD		readRealPar.val	{L:35}
(*) UNDEF
A0011D80  60D0CF85		ld.w d15, #0x30D90 ; ADR 0xC0000D90

#96			ST		RatKTrq	{L:35}
(*) REAL
A0011D84  60ECCFA5		st.w #0x30DAC, d15 ; ADR 0xC0000DAC

#97		
#98			(* RatedTorque := RatCur*RatKTrq; *)
#99			LD		RatCur	{L:36}
(*) UNDEF
A0011D88  60E8CF85		ld.w d15, #0x30DA8 ; ADR 0xC0000DA8

#100			MUL		RatKTrq	{L:36}
(*) REAL
A0011D8C  60ECC885		ld.w d8, #0x30DAC ; ADR 0xC0000DAC
A0011D90  F0418F4B		mul.f d15, d15, d8

#101			ST		RatedTorque	{L:36}
(*) REAL
A0011D94  60F0CFA5		st.w #0x30DB0, d15 ; ADR 0xC0000DB0

#102		
#103			(* KNm2Cnt := TO_REAL(TrqToCount(1.0 / RatedTorque * 100.0)); *)
#104			LD		1.0	{L:38}
(*) UNDEF
A0011D98  F00000BB		mov.u d15, #0x0000 ; COSTREAL 1.000000
A0011D9C  F3F80F9B		addih d15, d15, #0x3F80

#105			DIV		RatedTorque	{L:38}
(*) REAL
A0011DA0  60F0C885		ld.w d8, #0x30DB0 ; ADR 0xC0000DB0
A0011DA4  F0518F4B		div.f d15, d15, d8

#106			MUL		100.0	{L:38}
(*) REAL
A0011DA8  800000BB		mov.u d8, #0x0000 ; COSTREAL 100.000000
A0011DAC  842C889B		addih d8, d8, #0x42C8
A0011DB0  F0418F4B		mul.f d15, d15, d8

#107			TrqToCount	{L:38}
(-) REAL
A0011DB4  41F0F00B		mov d4, d15
A0011DB8  F17AFF6D		call #0xFFF17A ; CALL 0xA00100AC
A0011DBC  F1F0200B		mov d15, d2

#108			TO_REAL	{L:38}
(*) DINT
A0011DC0  F1410F4B		itof d15, d15

#109			ST		KNm2Cnt	{L:38}
(*) REAL
A0011DC4  50F8CFA5		st.w #0x30D78, d15 ; ADR 0xC0000D78

#110		
#111			(* InputConv.KCnt2Nm := 1.0 / KNm2Cnt; *)
#112			LD		1.0	{L:39}
(*) UNDEF
A0011DC8  F00000BB		mov.u d15, #0x0000 ; COSTREAL 1.000000
A0011DCC  F3F80F9B		addih d15, d15, #0x3F80

#113			DIV		KNm2Cnt	{L:39}
(*) REAL
A0011DD0  50F8C885		ld.w d8, #0x30D78 ; ADR 0xC0000D78
A0011DD4  F0518F4B		div.f d15, d15, d8

#114			ST		InputConv.KCnt2Nm	{L:39}
(*) REAL
A0011DD8  304CCFA5		st.w #0x304CC, d15 ; ADR 0xC00004CC

#115		
#116			(* MaxTorque := 10.0; *)
#117			LD		10.0	{L:44}
(*) UNDEF
A0011DDC  F00000BB		mov.u d15, #0x0000 ; COSTREAL 10.000000
A0011DE0  F4120F9B		addih d15, d15, #0x4120

#118			ST		MaxTorque	{L:44}
(*) REAL
A0011DE4  60F4CFA5		st.w #0x30DB4, d15 ; ADR 0xC0000DB4

#119		
#120			(* ENABLE_CYCLIC_PRG := TRUE; *)
#121			LD		TRUE	{L:49}
(*) UNDEF
A0011DE8  F000103B		mov d15, #1

#122			ST		ENABLE_CYCLIC_PRG	{L:49}
(*) BOOL
A0011DEC  50D0CFA5		st.w #0x30D50, d15 ; ADR 0xC0000D50

#123		
#124			(* INIT_END := TRUE; *)
#125			LD		TRUE	{L:50}
(*) UNDEF
A0011DF0  F000103B		mov d15, #1

#126			ST		INIT_END	{L:50}
(*) BOOL
A0011DF4  60C0CFA5		st.w #0x30D80, d15 ; ADR 0xC0000D80

#127		
#128			(* CYCLE_STOP := FALSE; *)
#129			LD		FALSE	{L:51}
(*) UNDEF
A0011DF8  F000003B		mov d15, #0

#130			ST		CYCLE_STOP	{L:51}
(*) BOOL
A0011DFC  60C4CFA5		st.w #0x30D84, d15 ; ADR 0xC0000D84

#131		
#132		
#133		(* Test condition TR2 pin_in 0 *)
#134			LD		INIT_END
(*) UNDEF
A0011E00  60C0CF85		ld.w d15, #0x30D80 ; ADR 0xC0000D80

#135			ST		state_machine$$Cycle_x
(*) BOOL
A0011E04  60F8CFA5		st.w #0x30DB8, d15 ; ADR 0xC0000DB8

#136			R		state_machine$$Init_x
(*) BOOL
A0011E08  FC000091		movh.a a15, #0xC000 ; ADR 0xC0000D7C
A0011E0C  50FCFFD9		lea a15,[a15]0x0D7C
A0011E10  0840F809		ld.bu d8, [a15]
A0011E14  8FA008AB		seln d8, d15, d8, #0
A0011E18  0800F889		st.b [a15], d8

#137		
#138		end_state_machine$Init:
#139			LD		state_machine$$Cycle_x
(*) UNDEF
A0011E1C  60F8CF85		ld.w d15, #0x30DB8 ; ADR 0xC0000DB8

#140			JMPCN	end_state_machine$Cycle
(-) BOOL
A0011E20  00480FDF		jeq d15, #0, #0x0048 ; JUMP 0xA0011EB0

#141		
#142		(* BODY OF Cycle *)
#143		{SRC:state_machine/Cycle_state}
#144		
#145		
#146			(* IF sysDIBitWordBit1 *)
#147			LD		sysDIBitWordBit1	{L:1}
(*) UNDEF
A0011E24  FC000091		movh.a a15, #0xC000 ; ADR 0xC00041A8
A0011E28  6428FF19		ld.w d15, [a15]0x41A8

#148			JMPCN	state_machine/Cycle_state$lab3	{L:1}
(-) BOOL
A0011E2C  002C0FDF		jeq d15, #0, #0x002C ; JUMP 0xA0011E84

#149		
#150			(* THEN *)
#151		
#152				(* ENABLE_CYCLIC_PRG := TRUE; *)
#153				LD		TRUE	{L:2}
(*) UNDEF
A0011E30  F000103B		mov d15, #1

#154				ST		ENABLE_CYCLIC_PRG	{L:2}
(*) BOOL
A0011E34  50D0CFA5		st.w #0x30D50, d15 ; ADR 0xC0000D50

#155		
#156		
#157				(* IF p_ControlMode>=0 AND p_ControlMode<=2 *)
#158				LD		p_ControlMode	{L:4}
(*) UNDEF
A0011E38  C9B4CF05		ld.h d15, #0x31B34 ; ADR 0xC0001B34

#159				LE		2	{L:4}
(*) INT
A0011E3C  8000203B		mov d8, #2
A0011E40  F140F80B		ge d15, d8, d15

#160				AND(		p_ControlMode	{L:4}
(*) BOOL
A0011E44  F53CAF89		st.w [-sp]4, d15 
A0011E48  C9B4CF05		ld.h d15, #0x31B34 ; ADR 0xC0001B34

#161				GE		0	{L:4}
(*) INT
A0011E4C  8000003B		mov d8, #0
A0011E50  F1408F0B		ge d15, d15, d8

#162				)	{L:4}
(*) BOOL
A0011E54  01F0F00B		mov d0, d15
A0011E58  0104AF09		ld.w d15, [sp+]4
A0011E5C  F0800F0F		and d15, d15, d0

#163				JMPCN	state_machine/Cycle_state$lab1	{L:4}
(-) BOOL
A0011E60  000A0FDF		jeq d15, #0, #0x000A ; JUMP 0xA0011E74

#164		
#165				(* THEN *)
#166		
#167					(* sysControlMode := p_ControlMode; *)
#168					LD		p_ControlMode	{L:5}
(*) UNDEF
A0011E64  C9B4CF05		ld.h d15, #0x31B34 ; ADR 0xC0001B34

#169					ST		sysControlMode	{L:5}
(*) INT
A0011E68  FC000091		movh.a a15, #0xC000 ; ADR 0xC00045D0
A0011E6C  7450FF59		st.w [a15]0x45D0, d15

#170					JMP		state_machine/Cycle_state$lab0
(-) INT
A0011E70  0008001D		j #0x000008 ; JUMP 0xA0011E80

#171		state_machine/Cycle_state$lab1:
#172		
#173				(* ELSE *)
#174		
#175					(* sysControlMode := 1; *)
#176					LD		1	{L:7}
(*) UNDEF
A0011E74  F000103B		mov d15, #1

#177					ST		sysControlMode	{L:7}
(*) USINT
A0011E78  FC000091		movh.a a15, #0xC000 ; ADR 0xC00045D0
A0011E7C  7450FF59		st.w [a15]0x45D0, d15

#178		
#179		state_machine/Cycle_state$lab0:
#180				(* END_IF *)
#181				JMP		state_machine/Cycle_state$lab2
(-) UDINT
A0011E80  000A001D		j #0x00000A ; JUMP 0xA0011E94

#182		state_machine/Cycle_state$lab3:
#183		
#184			(* ELSE *)
#185		
#186				(* ENABLE_CYCLIC_PRG := FALSE; *)
#187				LD		FALSE	{L:10}
(*) UNDEF
A0011E84  F000003B		mov d15, #0

#188				ST		ENABLE_CYCLIC_PRG	{L:10}
(*) BOOL
A0011E88  50D0CFA5		st.w #0x30D50, d15 ; ADR 0xC0000D50

#189		
#190				(* p_ControlMode:=1; *)
#191				LD		1	{L:11}
(*) UNDEF
A0011E8C  F000103B		mov d15, #1

#192				ST		p_ControlMode	{L:11}
(*) USINT
A0011E90  C9B4CF25		st.h #0x31B34, d15 ; ADR 0xC0001B34

#193		
#194		state_machine/Cycle_state$lab2:
#195			(* END_IF *)
#196		
#197		
#198		(* Test condition TR4 pin_in 0 *)
#199			LD		CYCLE_STOP
(*) UNDEF
A0011E94  60C4CF85		ld.w d15, #0x30D84 ; ADR 0xC0000D84

#200			ST		state_machine$$Stop_x
(*) BOOL
A0011E98  60FCCFA5		st.w #0x30DBC, d15 ; ADR 0xC0000DBC

#201			R		state_machine$$Cycle_x
(*) BOOL
A0011E9C  FC000091		movh.a a15, #0xC000 ; ADR 0xC0000DB8
A0011EA0  60F8FFD9		lea a15,[a15]0x0DB8
A0011EA4  0840F809		ld.bu d8, [a15]
A0011EA8  8FA008AB		seln d8, d15, d8, #0
A0011EAC  0800F889		st.b [a15], d8

#202		
#203		end_state_machine$Cycle:
#204			LD		state_machine$$Stop_x
(*) UNDEF
A0011EB0  60FCCF85		ld.w d15, #0x30DBC ; ADR 0xC0000DBC

#205			JMPCN	end_state_machine$Stop
(-) BOOL
A0011EB4  001E0FDF		jeq d15, #0, #0x001E ; JUMP 0xA0011EF0

#206		
#207		(* BODY OF Stop *)
#208		{SRC:state_machine/Stop_state}
#209		
#210			(* ENABLE_CYCLIC_PRG := FALSE; *)
#211			LD		FALSE	{L:1}
(*) UNDEF
A0011EB8  F000003B		mov d15, #0

#212			ST		ENABLE_CYCLIC_PRG	{L:1}
(*) BOOL
A0011EBC  50D0CFA5		st.w #0x30D50, d15 ; ADR 0xC0000D50

#213		
#214			(* CYCLE_STOP := TRUE; *)
#215			LD		TRUE	{L:2}
(*) UNDEF
A0011EC0  F000103B		mov d15, #1

#216			ST		CYCLE_STOP	{L:2}
(*) BOOL
A0011EC4  60C4CFA5		st.w #0x30D84, d15 ; ADR 0xC0000D84

#217		
#218			(* v_Torque := 0.0; *)
#219			LD		0.0	{L:4}
(*) UNDEF
A0011EC8  F00000BB		mov.u d15, #0x0000 ; COSTREAL 0.000000
A0011ECC  F0000F9B		addih d15, d15, #0x0000

#220			ST		v_Torque	{L:4}
(*) REAL
A0011ED0  0234CFA5		st.w #0x32034, d15 ; ADR 0xC0002034

#221		
#222		
#223		(* Test condition TR5 pin_in 0 *)
#224			LD		CYCLE_STOP
(*) UNDEF
A0011ED4  60C4CF85		ld.w d15, #0x30D84 ; ADR 0xC0000D84

#225			ST		state_machine$$Jump6_x
(*) BOOL
A0011ED8  70C0CFA5		st.w #0x30DC0, d15 ; ADR 0xC0000DC0

#226			R		state_machine$$Stop_x
(*) BOOL
A0011EDC  FC000091		movh.a a15, #0xC000 ; ADR 0xC0000DBC
A0011EE0  60FCFFD9		lea a15,[a15]0x0DBC
A0011EE4  0840F809		ld.bu d8, [a15]
A0011EE8  8FA008AB		seln d8, d15, d8, #0
A0011EEC  0800F889		st.b [a15], d8

#227		
#228		end_state_machine$Stop:
#229			LD		state_machine$$Jump6_x
(*) UNDEF
A0011EF0  70C0CF85		ld.w d15, #0x30DC0 ; ADR 0xC0000DC0

#230			JMPCN	end_state_machine$Jump6
(-) BOOL
A0011EF4  00100FDF		jeq d15, #0, #0x0010 ; JUMP 0xA0011F14

#231		
#232		(* JUMP TO Stop *)
#233			LD		TRUE
(*) UNDEF
A0011EF8  F000103B		mov d15, #1

#234			ST		state_machine$$Stop_x
(*) BOOL
A0011EFC  60FCCFA5		st.w #0x30DBC, d15 ; ADR 0xC0000DBC

#235			R		state_machine$$Jump6_x
(*) BOOL
A0011F00  FC000091		movh.a a15, #0xC000 ; ADR 0xC0000DC0
A0011F04  70C0FFD9		lea a15,[a15]0x0DC0
A0011F08  0840F809		ld.bu d8, [a15]
A0011F0C  8FA008AB		seln d8, d15, d8, #0
A0011F10  0800F889		st.b [a15], d8

A0011F14  0180000D		ret

END_PROGRAM


**************************************************
	Target variable image generation
**************************************************


*** INPUT:
A0011F18  0180000D		ret


*** OUTPUT:
A0011F1C  0180000D		ret



**************************************************
	Init code generation for task Background
**************************************************

A0011F20  F000103B		mov d15, #1
A0011F24  50FCCFA5		st.w #0x30D7C, d15 ; ADR 0xC0000D7C

A0011F28  0180000D		ret



**************************************************
	Global init code generation
**************************************************

A0011F40  0180000D		ret



********************************************
MEMORY MAP
********************************************

Start code area:			A0010000h
End code area:				A0011F50h
Code size:					    1F50h

Start local data area:		C00004BCh
End local data area:		C0000DC4h
Local data size:			     908h

Start retentive data area:	C0001ABCh
End retentive data area:	C0001ABCh
Retentive data size:		       0h

Start bit data area:		C0001AFCh
End bit data area:			C0001AFCh
Bit data size:				       0h



----------------------------------
ADDRESS MAP
----------------------------------

               C00004BC (4) $$STKLIMIT$$
               C00004C0 (4) InputConv.Krpm
               C00004C4 (4) InputConv.Krad_s
               C00004C8 (4) InputConv.KArms
               C00004CC (4) InputConv.KCnt2Nm
               C00004D0 (4) InputConv.sysPos
               C00004D4 (4) InputConv.sysSpd
               C00004D8 (4) InputConv.sysIq
               C00004DC (4) InputConv.sysTrqRef
               C00004E0 (4) InputConv.PosDINT
               C00004E4 (4) InputConv.offset
               C00004E8 (4) InputConv.sysRev
               C00004EC (4) InputConv.pos
               C00004F0 (4) InputConv.vel_rpm
               C00004F4 (4) InputConv.vel
               C00004F8 (4) InputConv.trq
               C00004FC (4) InputConv.curr
               C0000500 (40) rms_Id.fast_buffer.buffer
               C0000528 (2) rms_Id.fast_buffer.idx
--FREE--       C000052A (2)
               C000052C (4) rms_Id.fast_buffer.input
               C0000530 (4) rms_Id.fast_buffer.sum
               C0000534 (4) rms_Id.fast_buffer.overflow
               C0000538 (40) rms_Id.medium_buffer.buffer
               C0000560 (2) rms_Id.medium_buffer.idx
--FREE--       C0000562 (2)
               C0000564 (4) rms_Id.medium_buffer.input
               C0000568 (4) rms_Id.medium_buffer.sum
               C000056C (4) rms_Id.medium_buffer.overflow
               C0000570 (40) rms_Id.slow_buffer.buffer
               C0000598 (2) rms_Id.slow_buffer.idx
--FREE--       C000059A (2)
               C000059C (4) rms_Id.slow_buffer.input
               C00005A0 (4) rms_Id.slow_buffer.sum
               C00005A4 (4) rms_Id.slow_buffer.overflow
               C00005A8 (4) rms_Id.input
               C00005AC (4) rms_Id.rms
               C00005B0 (40) rms_Iq.fast_buffer.buffer
               C00005D8 (2) rms_Iq.fast_buffer.idx
--FREE--       C00005DA (2)
               C00005DC (4) rms_Iq.fast_buffer.input
               C00005E0 (4) rms_Iq.fast_buffer.sum
               C00005E4 (4) rms_Iq.fast_buffer.overflow
               C00005E8 (40) rms_Iq.medium_buffer.buffer
               C0000610 (2) rms_Iq.medium_buffer.idx
--FREE--       C0000612 (2)
               C0000614 (4) rms_Iq.medium_buffer.input
               C0000618 (4) rms_Iq.medium_buffer.sum
               C000061C (4) rms_Iq.medium_buffer.overflow
               C0000620 (40) rms_Iq.slow_buffer.buffer
               C0000648 (2) rms_Iq.slow_buffer.idx
--FREE--       C000064A (2)
               C000064C (4) rms_Iq.slow_buffer.input
               C0000650 (4) rms_Iq.slow_buffer.sum
               C0000654 (4) rms_Iq.slow_buffer.overflow
               C0000658 (4) rms_Iq.input
               C000065C (4) rms_Iq.rms
               C0000660 (40) rms_Iout.fast_buffer.buffer
               C0000688 (2) rms_Iout.fast_buffer.idx
--FREE--       C000068A (2)
               C000068C (4) rms_Iout.fast_buffer.input
               C0000690 (4) rms_Iout.fast_buffer.sum
               C0000694 (4) rms_Iout.fast_buffer.overflow
               C0000698 (40) rms_Iout.medium_buffer.buffer
               C00006C0 (2) rms_Iout.medium_buffer.idx
--FREE--       C00006C2 (2)
               C00006C4 (4) rms_Iout.medium_buffer.input
               C00006C8 (4) rms_Iout.medium_buffer.sum
               C00006CC (4) rms_Iout.medium_buffer.overflow
               C00006D0 (40) rms_Iout.slow_buffer.buffer
               C00006F8 (2) rms_Iout.slow_buffer.idx
--FREE--       C00006FA (2)
               C00006FC (4) rms_Iout.slow_buffer.input
               C0000700 (4) rms_Iout.slow_buffer.sum
               C0000704 (4) rms_Iout.slow_buffer.overflow
               C0000708 (4) rms_Iout.input
               C000070C (4) rms_Iout.rms
               C0000710 (40) rms_Vdc.fast_buffer.buffer
               C0000738 (2) rms_Vdc.fast_buffer.idx
--FREE--       C000073A (2)
               C000073C (4) rms_Vdc.fast_buffer.input
               C0000740 (4) rms_Vdc.fast_buffer.sum
               C0000744 (4) rms_Vdc.fast_buffer.overflow
               C0000748 (40) rms_Vdc.medium_buffer.buffer
               C0000770 (2) rms_Vdc.medium_buffer.idx
--FREE--       C0000772 (2)
               C0000774 (4) rms_Vdc.medium_buffer.input
               C0000778 (4) rms_Vdc.medium_buffer.sum
               C000077C (4) rms_Vdc.medium_buffer.overflow
               C0000780 (40) rms_Vdc.slow_buffer.buffer
               C00007A8 (2) rms_Vdc.slow_buffer.idx
--FREE--       C00007AA (2)
               C00007AC (4) rms_Vdc.slow_buffer.input
               C00007B0 (4) rms_Vdc.slow_buffer.sum
               C00007B4 (4) rms_Vdc.slow_buffer.overflow
               C00007B8 (4) rms_Vdc.input
               C00007BC (4) rms_Vdc.rms
               C00007C0 (40) rms_Vo.fast_buffer.buffer
               C00007E8 (2) rms_Vo.fast_buffer.idx
--FREE--       C00007EA (2)
               C00007EC (4) rms_Vo.fast_buffer.input
               C00007F0 (4) rms_Vo.fast_buffer.sum
               C00007F4 (4) rms_Vo.fast_buffer.overflow
               C00007F8 (40) rms_Vo.medium_buffer.buffer
               C0000820 (2) rms_Vo.medium_buffer.idx
--FREE--       C0000822 (2)
               C0000824 (4) rms_Vo.medium_buffer.input
               C0000828 (4) rms_Vo.medium_buffer.sum
               C000082C (4) rms_Vo.medium_buffer.overflow
               C0000830 (40) rms_Vo.slow_buffer.buffer
               C0000858 (2) rms_Vo.slow_buffer.idx
--FREE--       C000085A (2)
               C000085C (4) rms_Vo.slow_buffer.input
               C0000860 (4) rms_Vo.slow_buffer.sum
               C0000864 (4) rms_Vo.slow_buffer.overflow
               C0000868 (4) rms_Vo.input
               C000086C (4) rms_Vo.rms
               C0000870 (40) rms_Speed.fast_buffer.buffer
               C0000898 (2) rms_Speed.fast_buffer.idx
--FREE--       C000089A (2)
               C000089C (4) rms_Speed.fast_buffer.input
               C00008A0 (4) rms_Speed.fast_buffer.sum
               C00008A4 (4) rms_Speed.fast_buffer.overflow
               C00008A8 (40) rms_Speed.medium_buffer.buffer
               C00008D0 (2) rms_Speed.medium_buffer.idx
--FREE--       C00008D2 (2)
               C00008D4 (4) rms_Speed.medium_buffer.input
               C00008D8 (4) rms_Speed.medium_buffer.sum
               C00008DC (4) rms_Speed.medium_buffer.overflow
               C00008E0 (40) rms_Speed.slow_buffer.buffer
               C0000908 (2) rms_Speed.slow_buffer.idx
--FREE--       C000090A (2)
               C000090C (4) rms_Speed.slow_buffer.input
               C0000910 (4) rms_Speed.slow_buffer.sum
               C0000914 (4) rms_Speed.slow_buffer.overflow
               C0000918 (4) rms_Speed.input
               C000091C (4) rms_Speed.rms
               C0000920 (40) mean_Vo.fast_buffer.buffer
               C0000948 (2) mean_Vo.fast_buffer.idx
--FREE--       C000094A (2)
               C000094C (4) mean_Vo.fast_buffer.input
               C0000950 (4) mean_Vo.fast_buffer.sum
               C0000954 (4) mean_Vo.fast_buffer.overflow
               C0000958 (40) mean_Vo.medium_buffer.buffer
               C0000980 (2) mean_Vo.medium_buffer.idx
--FREE--       C0000982 (2)
               C0000984 (4) mean_Vo.medium_buffer.input
               C0000988 (4) mean_Vo.medium_buffer.sum
               C000098C (4) mean_Vo.medium_buffer.overflow
               C0000990 (40) mean_Vo.slow_buffer.buffer
               C00009B8 (2) mean_Vo.slow_buffer.idx
--FREE--       C00009BA (2)
               C00009BC (4) mean_Vo.slow_buffer.input
               C00009C0 (4) mean_Vo.slow_buffer.sum
               C00009C4 (4) mean_Vo.slow_buffer.overflow
               C00009C8 (4) mean_Vo.input
               C00009CC (4) mean_Vo.mean
               C00009D0 (40) mean_Vdc.fast_buffer.buffer
               C00009F8 (2) mean_Vdc.fast_buffer.idx
--FREE--       C00009FA (2)
               C00009FC (4) mean_Vdc.fast_buffer.input
               C0000A00 (4) mean_Vdc.fast_buffer.sum
               C0000A04 (4) mean_Vdc.fast_buffer.overflow
               C0000A08 (40) mean_Vdc.medium_buffer.buffer
               C0000A30 (2) mean_Vdc.medium_buffer.idx
--FREE--       C0000A32 (2)
               C0000A34 (4) mean_Vdc.medium_buffer.input
               C0000A38 (4) mean_Vdc.medium_buffer.sum
               C0000A3C (4) mean_Vdc.medium_buffer.overflow
               C0000A40 (40) mean_Vdc.slow_buffer.buffer
               C0000A68 (2) mean_Vdc.slow_buffer.idx
--FREE--       C0000A6A (2)
               C0000A6C (4) mean_Vdc.slow_buffer.input
               C0000A70 (4) mean_Vdc.slow_buffer.sum
               C0000A74 (4) mean_Vdc.slow_buffer.overflow
               C0000A78 (4) mean_Vdc.input
               C0000A7C (4) mean_Vdc.mean
               C0000A80 (40) mean_Speed.fast_buffer.buffer
               C0000AA8 (2) mean_Speed.fast_buffer.idx
--FREE--       C0000AAA (2)
               C0000AAC (4) mean_Speed.fast_buffer.input
               C0000AB0 (4) mean_Speed.fast_buffer.sum
               C0000AB4 (4) mean_Speed.fast_buffer.overflow
               C0000AB8 (40) mean_Speed.medium_buffer.buffer
               C0000AE0 (2) mean_Speed.medium_buffer.idx
--FREE--       C0000AE2 (2)
               C0000AE4 (4) mean_Speed.medium_buffer.input
               C0000AE8 (4) mean_Speed.medium_buffer.sum
               C0000AEC (4) mean_Speed.medium_buffer.overflow
               C0000AF0 (40) mean_Speed.slow_buffer.buffer
               C0000B18 (2) mean_Speed.slow_buffer.idx
--FREE--       C0000B1A (2)
               C0000B1C (4) mean_Speed.slow_buffer.input
               C0000B20 (4) mean_Speed.slow_buffer.sum
               C0000B24 (4) mean_Speed.slow_buffer.overflow
               C0000B28 (4) mean_Speed.input
               C0000B2C (4) mean_Speed.mean
               C0000B30 (40) mean_Iout.fast_buffer.buffer
               C0000B58 (2) mean_Iout.fast_buffer.idx
--FREE--       C0000B5A (2)
               C0000B5C (4) mean_Iout.fast_buffer.input
               C0000B60 (4) mean_Iout.fast_buffer.sum
               C0000B64 (4) mean_Iout.fast_buffer.overflow
               C0000B68 (40) mean_Iout.medium_buffer.buffer
               C0000B90 (2) mean_Iout.medium_buffer.idx
--FREE--       C0000B92 (2)
               C0000B94 (4) mean_Iout.medium_buffer.input
               C0000B98 (4) mean_Iout.medium_buffer.sum
               C0000B9C (4) mean_Iout.medium_buffer.overflow
               C0000BA0 (40) mean_Iout.slow_buffer.buffer
               C0000BC8 (2) mean_Iout.slow_buffer.idx
--FREE--       C0000BCA (2)
               C0000BCC (4) mean_Iout.slow_buffer.input
               C0000BD0 (4) mean_Iout.slow_buffer.sum
               C0000BD4 (4) mean_Iout.slow_buffer.overflow
               C0000BD8 (4) mean_Iout.input
               C0000BDC (4) mean_Iout.mean
               C0000BE0 (40) mean_Iq.fast_buffer.buffer
               C0000C08 (2) mean_Iq.fast_buffer.idx
--FREE--       C0000C0A (2)
               C0000C0C (4) mean_Iq.fast_buffer.input
               C0000C10 (4) mean_Iq.fast_buffer.sum
               C0000C14 (4) mean_Iq.fast_buffer.overflow
               C0000C18 (40) mean_Iq.medium_buffer.buffer
               C0000C40 (2) mean_Iq.medium_buffer.idx
--FREE--       C0000C42 (2)
               C0000C44 (4) mean_Iq.medium_buffer.input
               C0000C48 (4) mean_Iq.medium_buffer.sum
               C0000C4C (4) mean_Iq.medium_buffer.overflow
               C0000C50 (40) mean_Iq.slow_buffer.buffer
               C0000C78 (2) mean_Iq.slow_buffer.idx
--FREE--       C0000C7A (2)
               C0000C7C (4) mean_Iq.slow_buffer.input
               C0000C80 (4) mean_Iq.slow_buffer.sum
               C0000C84 (4) mean_Iq.slow_buffer.overflow
               C0000C88 (4) mean_Iq.input
               C0000C8C (4) mean_Iq.mean
               C0000C90 (40) mean_Id.fast_buffer.buffer
               C0000CB8 (2) mean_Id.fast_buffer.idx
--FREE--       C0000CBA (2)
               C0000CBC (4) mean_Id.fast_buffer.input
               C0000CC0 (4) mean_Id.fast_buffer.sum
               C0000CC4 (4) mean_Id.fast_buffer.overflow
               C0000CC8 (40) mean_Id.medium_buffer.buffer
               C0000CF0 (2) mean_Id.medium_buffer.idx
--FREE--       C0000CF2 (2)
               C0000CF4 (4) mean_Id.medium_buffer.input
               C0000CF8 (4) mean_Id.medium_buffer.sum
               C0000CFC (4) mean_Id.medium_buffer.overflow
               C0000D00 (40) mean_Id.slow_buffer.buffer
               C0000D28 (2) mean_Id.slow_buffer.idx
--FREE--       C0000D2A (2)
               C0000D2C (4) mean_Id.slow_buffer.input
               C0000D30 (4) mean_Id.slow_buffer.sum
               C0000D34 (4) mean_Id.slow_buffer.overflow
               C0000D38 (4) mean_Id.input
               C0000D3C (4) mean_Id.mean
               C0000D40 (4) sysSpd
               C0000D44 (4) sysPos
               C0000D48 (4) sysIq
               C0000D4C (4) sysRev
               C0000D50 (4) ENABLE_CYCLIC_PRG
               C0000D54 (4) speed_cmd
               C0000D58 (4) torque_cmd
               C0000D5C (4) torque_max
               C0000D60 (4) sysId
               C0000D64 (4) Cnt2A
               C0000D68 (4) sysIout
               C0000D6C (4) sysVdcLink
               C0000D70 (4) sysVo
               C0000D74 (4) VelConv
               C0000D78 (4) KNm2Cnt
               C0000D7C (4) state_machine$$Init_x
               C0000D80 (4) INIT_END
               C0000D84 (4) CYCLE_STOP
               C0000D88 (4) readRealPar.ipa
               C0000D8C (4) readRealPar.result
               C0000D90 (4) readRealPar.val
               C0000D94 (4) DriveRatCur
               C0000D98 (4) readIntPar.ipa
               C0000D9C (4) readIntPar.result
               C0000DA0 (4) readIntPar.val
               C0000DA4 (4) FullScaleSpeed
               C0000DA8 (4) RatCur
               C0000DAC (4) RatKTrq
               C0000DB0 (4) RatedTorque
               C0000DB4 (4) MaxTorque
               C0000DB8 (4) state_machine$$Cycle_x
               C0000DBC (4) state_machine$$Stop_x
               C0000DC0 (4) state_machine$$Jump6_x
--FREE--       C0000DC4 (3432)
               C0001B2C (4) p_MotorSpeedTarget
--FREE--       C0001B30 (4)
               C0001B34 (2) p_ControlMode
--FREE--       C0001B36 (2)
               C0001B38 (4) p_MotorTorqueRef
--FREE--       C0001B3C (1264)
               C000202C (4) v_Position
               C0002030 (4) v_Speed
               C0002034 (4) v_Torque
--FREE--       C0002038 (8)
               C0002040 (4) v_rms_Iq
               C0002044 (4) v_rms_Id
               C0002048 (4) v_rms_Iout
               C000204C (4) v_rms_Vdc
               C0002050 (4) v_rms_Vo
               C0002054 (4) v_rms_Speed
               C0002058 (4) v_temperature
               C000205C (4) v_mean_Iq
               C0002060 (4) v_mean_Id
               C0002064 (4) v_mean_Iout
               C0002068 (4) v_mean_Vdc
               C000206C (4) v_mean_Vo
               C0002070 (4) v_mean_Speed
--FREE--       C0002074 (8500)
               C00041A8 (4) sysDIBitWordBit1
--FREE--       C00041AC (1060)
               C00045D0 (4) sysControlMode
--FREE--       C00045D4 (268428628)
               D0002B28 (4) sysTrqFFwd
--FREE--       D0002B2C (388)
               D0002CB0 (4) sysSpeedPosPulsesPerRev
--FREE--       D0002CB4 (2036)
               D00034A8 (4) sysTrqRef
--FREE--       D00034AC (996)
               D0003890 (4) sysHeatSinkTemp
--FREE--       D0003894 (1100)
               D0003CE0 (4) sysSpdRef1


